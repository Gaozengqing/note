const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/en/\":{\"documentCount\":0,\"nextId\":0,\"documentIds\":{},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{},\"averageFieldLength\":[],\"storedFields\":{},\"dirtCount\":0,\"index\":[],\"serializationVersion\":2},\"/\":{\"documentCount\":164,\"nextId\":164,\"documentIds\":{\"0\":\"v-22a39d25\",\"1\":\"v-8daa1a0e\",\"2\":\"v-39abfe04\",\"3\":\"v-39abfe04#a\",\"4\":\"v-39abfe04#c\",\"5\":\"v-39abfe04#i\",\"6\":\"v-39abfe04#d\",\"7\":\"v-39abfe04#事务的开启\",\"8\":\"v-39abfe04#事务的提交\",\"9\":\"v-39abfe04#事务回滚\",\"10\":\"v-39abfe04#tip\",\"11\":\"v-39abfe04#事物的自动提交\",\"12\":\"v-39abfe04#事务的保持点\",\"13\":\"v-39abfe04#tip-1\",\"14\":\"v-8dcee60a\",\"15\":\"v-8dcee60a#一、安装和启动mysql\",\"16\":\"v-8dcee60a#流程\",\"17\":\"v-8dcee60a#安装命令\",\"18\":\"v-8dcee60a#卸载命令\",\"19\":\"v-8dcee60a#mysql配置文件\",\"20\":\"v-8dcee60a#常用配置\",\"21\":\"v-8dcee60a#初始化mysql数据库\",\"22\":\"v-8dcee60a#启动mysql服务\",\"23\":\"v-8dcee60a#停止mysql服务\",\"24\":\"v-8dcee60a#二、mysql的登录和退出-密码设置\",\"25\":\"v-8dcee60a#登录\",\"26\":\"v-8dcee60a#退出\",\"27\":\"v-8dcee60a#配置环境变量\",\"28\":\"v-8dcee60a#修改密码\",\"29\":\"v-8dcee60a#扩展-intellij-idea图形化管理工具\",\"30\":\"v-8dcee60a#三、数据库设计-了解\",\"31\":\"v-8dcee60a#_6个阶段\",\"32\":\"v-8dcee60a#_1、数据库设计人员需要分析用户的需求-将分析的结果记录下来-形成需求分析报告。\",\"33\":\"v-8dcee60a#_2、整个数据库设计的关键阶段-通过对用户的需求进行综合、归纳与抽象-形成一个概念数据模型。一般通过绘制e-r图-直观呈现数据库设计人员对用户需求的理解。\",\"34\":\"v-8dcee60a#_3、将e-r图转换为数据库管理系统所支持的数据模型-如关系模型-完成实体、属性和联系的转换。\",\"35\":\"v-8dcee60a#_4、为逻辑数据模型确定数据库的存储结构、文件类型等。通常数据库管理系统为了保证其独立性与可移植性-承担了大部分任务-数据库设计人员只需考虑硬件、操作系统的特性-为数据表选择合适的存储引擎-为字段选择合适的数据类型-以及评估磁盘空间需求等工作。\",\"36\":\"v-8dcee60a#_5、设计人员根据逻辑设计和物理设计的结果建立数据库-编写与调试应用程序-组织数据入库-并进行试运行。如使用sql语句创建数据库、数据表等。\",\"37\":\"v-8dcee60a#_6、在数据库运行和维护阶段-将数据库应用系统正式投入运行-在运行过程中不断进行一些维护、调整、备份和升级等工作。\",\"38\":\"v-8dcee60a#数据库设计范式\",\"39\":\"v-8dcee60a#关系代数\",\"40\":\"v-5b17d198\",\"41\":\"v-5b17d198#连接查询\",\"42\":\"v-5b17d198#交叉连接查询\",\"43\":\"v-5b17d198#内连接查询\",\"44\":\"v-5b17d198#自查询\",\"45\":\"v-5b17d198#联合查询\",\"46\":\"v-5b17d198#外连接\",\"47\":\"v-5b17d198#左外\",\"48\":\"v-5b17d198#右外\",\"49\":\"v-5b17d198#tip\",\"50\":\"v-5b17d198#子查询\",\"51\":\"v-5b17d198#标量子查询\",\"52\":\"v-5b17d198#列子查询\",\"53\":\"v-5b17d198#行子查询\",\"54\":\"v-5b17d198#表子查询\",\"55\":\"v-5b17d198#exists子查询\",\"56\":\"v-4912ae1e\",\"57\":\"v-4912ae1e#创建与查看\",\"58\":\"v-4912ae1e#tip\",\"59\":\"v-4912ae1e#创建\",\"60\":\"v-4912ae1e#查看\",\"61\":\"v-4912ae1e#tip-1\",\"62\":\"v-4912ae1e#tip-2\",\"63\":\"v-4912ae1e#选择数据库\",\"64\":\"v-4912ae1e#建表语句\",\"65\":\"v-4912ae1e#查看所有的存储引擎\",\"66\":\"v-4912ae1e#查看数据表\",\"67\":\"v-4912ae1e#查看建表语句\",\"68\":\"v-4912ae1e#使用desc语句查看数据表结构\",\"69\":\"v-4912ae1e#修改和删除\",\"70\":\"v-4912ae1e#修改数据库\",\"71\":\"v-4912ae1e#删除数据库\",\"72\":\"v-4912ae1e#修改数据表名称\",\"73\":\"v-4912ae1e#修改数据表字段名称\",\"74\":\"v-4912ae1e#修改数据表中字段的数据类型\",\"75\":\"v-4912ae1e#为数据表添加指定字段\",\"76\":\"v-4912ae1e#修改数据表中字段的排列位置\",\"77\":\"v-4912ae1e#删除数据表中的指定字段\",\"78\":\"v-4912ae1e#删除数据表\",\"79\":\"v-4912ae1e#数据库的约束\",\"80\":\"v-4912ae1e#非空约束\",\"81\":\"v-4912ae1e#唯一约束\",\"82\":\"v-4912ae1e#tip-3\",\"83\":\"v-4912ae1e#tip-4\",\"84\":\"v-4912ae1e#删除唯一约束\",\"85\":\"v-4912ae1e#主键约束\",\"86\":\"v-4912ae1e#删除主键约束\",\"87\":\"v-4912ae1e#设置字段自动增长\",\"88\":\"v-4912ae1e#tip-5\",\"89\":\"v-4912ae1e#设置默认值约束\",\"90\":\"v-4912ae1e#删除默认值约束\",\"91\":\"v-5a49b447\",\"92\":\"v-5a49b447#添加数据\",\"93\":\"v-5a49b447#单条\",\"94\":\"v-5a49b447#多条\",\"95\":\"v-5a49b447#更新数据\",\"96\":\"v-5a49b447#部分\",\"97\":\"v-5a49b447#全部\",\"98\":\"v-5a49b447#删除数据\",\"99\":\"v-5a49b447#部分-1\",\"100\":\"v-5a49b447#全部-1\",\"101\":\"v-5a49b447#使用truncate语句来删除数据表中所有的数据\",\"102\":\"v-70fd4532\",\"103\":\"v-70fd4532#tip\",\"104\":\"v-70fd4532#索引的使用\",\"105\":\"v-70fd4532#创建\",\"106\":\"v-70fd4532#再创建数据表的同时创建索引\",\"107\":\"v-70fd4532#为已有的数据表创建索引\",\"108\":\"v-70fd4532#修改数据表的同时创建索引\",\"109\":\"v-70fd4532#查看索引\",\"110\":\"v-70fd4532#分析sql是否使用索引\",\"111\":\"v-70fd4532#删除索引\",\"112\":\"v-cc02ac5c\",\"113\":\"v-cc02ac5c#基于单表的视图\",\"114\":\"v-cc02ac5c#创建\",\"115\":\"v-cc02ac5c#基于多表的视图\",\"116\":\"v-cc02ac5c#创建-1\",\"117\":\"v-cc02ac5c#查看视图\",\"118\":\"v-cc02ac5c#查看视图的字段信息\",\"119\":\"v-cc02ac5c#查看视图的状态信息\",\"120\":\"v-cc02ac5c#查看视图的创建语句\",\"121\":\"v-cc02ac5c#修改视图\",\"122\":\"v-cc02ac5c#通过视图来操作数据\",\"123\":\"v-cc02ac5c#删除视图\",\"124\":\"v-422a8f40\",\"125\":\"v-1ae7a079\",\"126\":\"v-1ae7a079#数据驱动视图\",\"127\":\"v-1ae7a079#响应式-变化侦听\",\"128\":\"v-1ae7a079#对象的响应式\",\"129\":\"v-1ae7a079#依赖收集\",\"130\":\"v-1ae7a079#何时收集\",\"131\":\"v-1ae7a079#何时通知依赖更新\",\"132\":\"v-1ae7a079#收集好的依赖放置在何处\",\"133\":\"v-1ae7a079#何为依赖\",\"134\":\"v-1ae7a079#如何将自己添加到对应的管理器中\",\"135\":\"v-1ae7a079#数组的响应式\",\"136\":\"v-1ae7a079#为什么对象和数组是两个分开实现\",\"137\":\"v-1ae7a079#何时收集-1\",\"138\":\"v-1ae7a079#何时通知依赖更新-1\",\"139\":\"v-1ae7a079#数组方法拦截器\",\"140\":\"v-1ae7a079#依赖收集到哪里\",\"141\":\"v-1ae7a079#不足之处\",\"142\":\"v-1ae7a079#解决方案\",\"143\":\"v-111caa1a\",\"144\":\"v-111caa1a#ast抽象语法树\",\"145\":\"v-111caa1a#字符串到render函数的流程\",\"146\":\"v-111caa1a#模板解析\",\"147\":\"v-111caa1a#html解析器\",\"148\":\"v-111caa1a#优化\",\"149\":\"v-111caa1a#代码生成\",\"150\":\"v-7b892c42\",\"151\":\"v-7b892c42#vnode的类型\",\"152\":\"v-7b892c42#vnode的作用\",\"153\":\"v-7b892c42#dom-diff\",\"154\":\"v-7b892c42#创建节点\",\"155\":\"v-7b892c42#删除节点\",\"156\":\"v-7b892c42#更新节点\",\"157\":\"v-7b892c42#更新子节点\",\"158\":\"v-7b892c42#优化更新子节点\",\"159\":\"v-7b892c42#优化策略\",\"160\":\"v-dcc9f8ec\",\"161\":\"v-aaa72ac6\",\"162\":\"v-2a167063\",\"163\":\"v-3521777e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,10],\"2\":[1,13],\"3\":[1,6],\"4\":[1,5],\"5\":[1,5],\"6\":[1,9],\"7\":[1,7],\"8\":[1,6],\"9\":[1,5],\"10\":[1,31],\"11\":[1,16],\"12\":[1,17],\"13\":[1,6],\"14\":[2],\"15\":[2],\"16\":[1,4],\"17\":[1,4],\"18\":[1,4],\"19\":[1,7],\"20\":[1,8],\"21\":[1,8],\"22\":[1,3],\"23\":[1,3],\"24\":[3],\"25\":[1,14],\"26\":[1,4],\"27\":[1,9],\"28\":[1,15],\"29\":[3,10],\"30\":[4],\"31\":[1,6],\"32\":[5],\"33\":[9],\"34\":[7],\"35\":[11],\"36\":[8],\"37\":[7],\"38\":[1,27],\"39\":[1,20],\"40\":[1],\"41\":[1],\"42\":[1,16],\"43\":[1,12],\"44\":[1,16],\"45\":[1,17],\"46\":[1],\"47\":[1,18],\"48\":[1,18],\"49\":[1,8],\"50\":[1],\"51\":[1,14],\"52\":[1,28],\"53\":[1,17],\"54\":[1,16],\"55\":[1,13],\"56\":[2],\"57\":[1,23],\"58\":[2,40],\"59\":[1,18],\"60\":[1,20],\"61\":[1,36],\"62\":[1,77],\"63\":[1,3],\"64\":[1,27],\"65\":[1,3],\"66\":[1,14],\"67\":[1,5],\"68\":[1,17],\"69\":[1],\"70\":[1,17],\"71\":[1,6],\"72\":[1,13],\"73\":[1,19],\"74\":[1,11],\"75\":[1,22],\"76\":[1,17],\"77\":[1,8],\"78\":[1,11],\"79\":[1],\"80\":[1,29],\"81\":[1,8],\"82\":[1,26],\"83\":[1,24],\"84\":[1,8],\"85\":[1,40],\"86\":[1,7],\"87\":[1,18],\"88\":[1,19],\"89\":[1,25],\"90\":[1,12],\"91\":[1],\"92\":[1],\"93\":[1,30],\"94\":[1,17],\"95\":[1],\"96\":[1,28],\"97\":[1,13],\"98\":[1],\"99\":[1,11],\"100\":[1,6],\"101\":[1,12],\"102\":[1,5],\"103\":[1,52],\"104\":[1],\"105\":[1],\"106\":[1,35],\"107\":[1,9],\"108\":[1,14],\"109\":[1,62],\"110\":[1,10],\"111\":[1,17],\"112\":[1,17],\"113\":[1],\"114\":[1,59],\"115\":[1],\"116\":[1,6],\"117\":[1,4],\"118\":[1,5],\"119\":[1,6],\"120\":[1,5],\"121\":[1,11],\"122\":[1,10],\"123\":[1,7],\"124\":[1,467],\"125\":[1],\"126\":[1,4],\"127\":[3],\"128\":[1,8],\"129\":[1,2],\"130\":[2,1],\"131\":[2,1],\"132\":[2,7],\"133\":[2,3],\"134\":[2,20],\"135\":[1],\"136\":[2,1],\"137\":[2,4],\"138\":[2,5],\"139\":[1,13],\"140\":[2,2],\"141\":[1,2],\"142\":[1,3],\"143\":[2,13],\"144\":[1,2],\"145\":[1,6],\"146\":[1,14],\"147\":[1,103],\"148\":[1],\"149\":[1],\"150\":[2,27],\"151\":[1,30],\"152\":[1,8],\"153\":[2,12],\"154\":[2,25],\"155\":[1,1],\"156\":[1,35],\"157\":[1,30],\"158\":[1,1],\"159\":[1,28],\"160\":[1],\"161\":[1],\"162\":[1],\"163\":[1]},\"averageFieldLength\":[1.408536585365854,17.453050409479765],\"storedFields\":{\"0\":{\"h\":\"Hello\"},\"1\":{\"h\":\"\",\"t\":[\"Vue源码解读\",\"数据响应式\",\"虚拟DOM\",\"模板解析\",\"实例方法\",\"全局Api\",\"生命周期\",\"指令\",\"过滤器\",\"内置组件\"]},\"2\":{\"h\":\"事务\",\"t\":[\"MySQL事务是一种保证一系列数据库操作（比如更新、删除等）在一个单一的工作单元中的完整性。如果这一系列操作中的任意一个步骤失败，整个操作都可以回滚，以保证数据库的一致性。\",\"特性： ACID，原子性，一致性，隔离性，持久性\"]},\"3\":{\"h\":\"A\",\"t\":[\"原子性指一个事务必须被视为一个不可分割的最小工作单元，只有事务中所有的数据库操作都执行成功，整个事务才算执行成功。事务中如果有任何一条SQL语句执行失败，已经执行成功的SQL语句也必须回滚。\"]},\"4\":{\"h\":\"C\",\"t\":[\"一致性指事务只能将数据库状态从一个一致性状态转变为另一个一致性状态。MySQL中的一致性主要由日志机制实现，通过日志记录数据库的所有变化，为事务恢复提供跟踪记录。\"]},\"5\":{\"h\":\"I\",\"t\":[\"隔离性指一个事务在执行时不受其他事务的影响。隔离性保证了未完成事务的所有操作与数据库系统的隔离，直到事务完成为止，才能看到事务的执行结果。\"]},\"6\":{\"h\":\"D\",\"t\":[\"持久性指事务一旦提交，其对数据库中数据的修改就是永久性的。事务的持久性不能做到百分之百的持久，只能从事务本身的角度来保证持久性，如果遇到一些外部原因（例如硬盘损坏）导致数据库发生故障，所有提交的数据可能都会丢失。\"]},\"7\":{\"h\":\"事务的开启\",\"t\":[\"默认情况下，用户执行的每一条SQL语句都会被当成单独的事务自动提交。如果想要将一组SQL语句作为一个事务，则需要显式地开启事务。\",\"start transaction; \"]},\"8\":{\"h\":\"事务的提交\",\"t\":[\"显式开启事务后，每一条SQL语句不再自动提交，用户需要手动提交，只有提交后其中的操作才会生效。\",\"COMMIT; \"]},\"9\":{\"h\":\"事务回滚\",\"t\":[\"如果不想提交当前事务，可以将事务取消（即回滚）。\",\"ROLLBACK; \"]},\"10\":{\"h\":\"Tip\",\"t\":[\"使用事务时的注意事项： ROLLBACK语句只能针对未提交的事务回滚，已提交的事务不能回滚。 当执行COMMIT语句或ROLLBACK语句后，当前事务就会自动结束。如果开启事务后直到MySQL会话结束时都没有提交事务，事务会自动回滚。事务不允许嵌套，如果执行START TRANSACTION语句之前，上一个事务还没有提交，此时执行START TRANSACTION语句会隐式执行上一个事务的提交操作。 事务主要是针对数据表中数据，不包括创建或删除数据库、数据表，修改表结构等操作，而且执行这类操作时会隐式地提交事务。 InnoDB存储引擎支持事务，MyISAM存储引擎不支持事务。MyISAM存储引擎的数据表，无论事务是否提交，对数据的操作都会立即生效，不能回滚。 使用START TRANSACTION的别名BEGIN或BEGIN WORK显式地开启一个事务。由于BEGIN与存储过程中的BEGIN…END冲突，因此不推荐使用BEGIN。\"]},\"11\":{\"h\":\"事物的自动提交\",\"t\":[\"用户执行的每一条SQL语句都会被当成单独的事务自动提交。 如果关闭事务的自动提交，事务只能手动提交，通过更改AUTOCOMMIT的值设置事务的提交方式。 AUTOCOMMIT的值设置为1表示开启事务自动提交，设置为0表示关闭事务自动提交。\",\"查看当前会话的AUTOCOMMIT值： SELECT @@AUTOCOMMIT; 关闭当前会话的事务自动提交： SET AUTOCOMMIT=0; -- 关闭后需要手动提交事务，如果未提交事务直接终止MySQL会话， -- 事务自动回滚。 \"]},\"12\":{\"h\":\"事务的保持点\",\"t\":[\"回滚事务后，事务内的所有操作将都被撤销，如果只希望撤销事务内的一部分操作，可以在事务中设置一个保存点。 设置保存点后，可以将事务回滚到指定的保存点。如果不再需要保存点，可以将保存点删除。\",\"在事务中设置保存点的语句\",\"SAVEPOINT 保存点名; \",\"将事务回滚至保存点的语句：\",\"ROLLBACK TO SAVEPOINT 保存点名; \",\"删除保存点的语句\",\"RELEASE SAVEPOINT 保存点名; \"]},\"13\":{\"h\":\"Tip\",\"t\":[\"一个事务中可以创建多个保存点，在提交事务后，事务中的保存点就会被删除。 当回滚到某个保存点后，该保存点之后创建的保存点也会被删除。\"]},\"14\":{\"h\":\"入门 🎉\"},\"15\":{\"h\":\"一、安装和启动Mysql\"},\"16\":{\"h\":\"流程\",\"t\":[\"安装MySQL服务\",\"创建MySQL配置文件\",\"初始化MySQL数据库\",\"启动MySQL服务\"]},\"17\":{\"h\":\"安装命令\",\"t\":[\"mysqld -install MySQL服务名称 \"]},\"18\":{\"h\":\"卸载命令\",\"t\":[\"mysqld -remove MySQL服务名称 \"]},\"19\":{\"h\":\"Mysql配置文件\",\"t\":[\"需要存放在MySQL安装目录命名为my.ini(windows)或my.cnf(Linux环境)\"]},\"20\":{\"h\":\"常用配置\",\"t\":[\"[mysqld] basedir=MySQL安装目录 datadir=MySQL数据库文件的存放目录 port=3306 \",\"port：MySQL客户端连接服务器端使用的端口号，默认为3306\"]},\"21\":{\"h\":\"初始化MySQL数据库\",\"t\":[\"两种方式\",\"mysqld --initialize-insecure (不会为默认用户root生成密码)\",\"mysqld --initialize --console(自动为默认用户root生成随机密码)\"]},\"22\":{\"h\":\"启动MySQL服务\",\"t\":[\"net start MySQL服务名称\"]},\"23\":{\"h\":\"停止MySQL服务\",\"t\":[\"net stop MySQL服务名称\"]},\"24\":{\"h\":\"二、Mysql的登录和退出，密码设置\"},\"25\":{\"h\":\"登录\",\"t\":[\"明文 mysql -h hostname -u username -ppassword -h是MySQL的主机名或ip -u用户名 -p密码\",\"非明文 mysql -h hostname -u username -p 回车 之后再数密码\"]},\"26\":{\"h\":\"退出\",\"t\":[\"exit; 或 quit;\"]},\"27\":{\"h\":\"配置环境变量\",\"t\":[\"以管理员身份运行命令提示符，将MySQL安装目录\\\\bin配置到PATH环境变量中。\",\"setx PATH \\\"%PATH%;MySQL安装目录\\\\bin\\\" \",\"测试是否成功:在非MySQL安装目录的bin中登录MySQL\"]},\"28\":{\"h\":\"修改密码\",\"t\":[\"# 格式如下 ALTER USER '用户'@'localhost' IDENTIFIED BY '新密码'; # eg:打开命令提示符，使用root用户登录MySQL，登录成功后将root用户的密码设置为123456。 ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; \"]},\"29\":{\"h\":\"扩展-IntelliJ IDEA图形化管理工具\",\"t\":[\"教程地址 https://blog.csdn.net/m0_67906358/article/details/129449631\"]},\"30\":{\"h\":\"三、数据库设计(了解)\"},\"31\":{\"h\":\"6个阶段\",\"t\":[\"需求分析\",\"概念结构设计\",\"逻辑结构设计\",\"物理结构设计\",\"数据库实施\",\"数据库运行与维护\"]},\"32\":{\"h\":\"1、数据库设计人员需要分析用户的需求，将分析的结果记录下来，形成需求分析报告。\"},\"33\":{\"h\":\"2、整个数据库设计的关键阶段，通过对用户的需求进行综合、归纳与抽象，形成一个概念数据模型。一般通过绘制E-R图，直观呈现数据库设计人员对用户需求的理解。\"},\"34\":{\"h\":\"3、将E-R图转换为数据库管理系统所支持的数据模型（如关系模型），完成实体、属性和联系的转换。\"},\"35\":{\"h\":\"4、为逻辑数据模型确定数据库的存储结构、文件类型等。通常数据库管理系统为了保证其独立性与可移植性，承担了大部分任务，数据库设计人员只需考虑硬件、操作系统的特性，为数据表选择合适的存储引擎，为字段选择合适的数据类型，以及评估磁盘空间需求等工作。\"},\"36\":{\"h\":\"5、设计人员根据逻辑设计和物理设计的结果建立数据库，编写与调试应用程序，组织数据入库，并进行试运行。如使用SQL语句创建数据库、数据表等。\"},\"37\":{\"h\":\"6、在数据库运行和维护阶段，将数据库应用系统正式投入运行，在运行过程中不断进行一些维护、调整、备份和升级等工作。\"},\"38\":{\"h\":\"数据库设计范式\",\"t\":[\"概念：数据库设计对数据的存储性能、数据的操作有很大影响。为了避免不规范的数据造成数据冗余，以及出现插入、删除、更新操作异常等情况，就要满足一定的规范化要求。为了规范化数据库，数据库技术专家们提出了各种范式（Normal Form）。\",\"指数据表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即数据表中不能有重复的字段，一个字段不能有多个值。 第一范式遵从原子性，字段不可再分。\",\"实体的字段完全依赖于主键，不能仅依赖主键的一部分（对于复合主键而言）。 第二范式遵从唯一性，非主键字段需完全依赖主键。\",\"要求一张数据表中每一列数据都和主键直接相关，而不能间接相关。 第三范式就是非主键字段不能相互依赖。\"]},\"39\":{\"h\":\"关系代数\",\"t\":[\"一、 集合运算符 笛卡儿积、并、交、差 二、关系运算符 除，选择，投影，连接\",\"提示\",\"提示内容\",\"警告\",\"警告内容\",\"危险\",\"危险内容\",\"详情\",\"详情内容\"]},\"40\":{\"h\":\"多表操作\"},\"41\":{\"h\":\"连接查询\"},\"42\":{\"h\":\"交叉连接查询\",\"t\":[\"A表中有3个字段4条记录，B表中有2个字段3条记录 结果表中有3+2个字段，4*3条记录\",\"完整写法: SELECT *|{字段名[, ...]} FROM 表1 CROSS JOIN 表2; 简写: SELECT *|{字段名[, ...]} FROM 表1, 表2; \"]},\"43\":{\"h\":\"内连接查询\",\"t\":[\"保存两个表中交集部分\",\"SELECT *|{字段名[, ...]} FROM 表1 [INNER] JOIN 表2 ON 连接条件; \"]},\"44\":{\"h\":\"自查询\",\"t\":[\"一张数据表与它自身连接,在物理上为同一张数据表，但逻辑上分为两张数据表。 自连接查询必须为表设置别名，需要通过别名对两张数据表进行区分。\",\"SELECT *|{字段名[, ...]} FROM 表1 别名1 JOIN 表1 别名2 ON 连接条件; \"]},\"45\":{\"h\":\"联合查询\",\"t\":[\"ALL关键字：表示保留所有查询结果。 DISTINCT关键字：默认选项，表示去除查询结果中完全重复的数据。 联合查询的字段来源于第一条查询语句，多个联合查询的字段数量必须一致(要和第一张表中的字段数一致)。\",\"SELECT *|{字段名[, ...]} FROM 表1 ... UNION [ALL|DISTINCT] SELECT *|{字段名[, ...]} FROM 表2 ...; \"]},\"46\":{\"h\":\"外连接\"},\"47\":{\"h\":\"左外\",\"t\":[\"左表的全部加上左右两表的交集 用左表的记录匹配右表的记录，查询结果中包括左表中的所有记录，以及右表中满足连接条件的记录。如果左表的某条记录在右表中不存在，则右表中对应字段的值显示为NULL。\",\"SELECT 表名.字段名[, ...] FROM 左表 LEFT [OUTER] JOIN 右表 ON 连接条件; \"]},\"48\":{\"h\":\"右外\",\"t\":[\"右表的全部加上左右两表的交集 用右表的记录匹配左表的记录，查询结果中包括右表中的所有记录，以及左表中满足连接条件的记录。如果右表的某条记录在左表中不存在，则左表中对应字段的值显示为NULL。\",\"SELECT 表名.字段名[, ...] FROM 左表 RIGHT [OUTER] JOIN 右表 ON 连接条件; \"]},\"49\":{\"h\":\"Tip\",\"t\":[\"左外连接查询和右外连接查询是可以相互替换的。当LEFT JOIN和RIGHT JOIN相互替换时，将左、右表的位置也相互替换，即可得到相同的结果。\"]},\"50\":{\"h\":\"子查询\"},\"51\":{\"h\":\"标量子查询\",\"t\":[\"返回结果为一行一列数据的子查询。\",\"SELECT *|{字段名[, ...]} FROM 表名 WHERE 字段名{=|<>|>|>=|<|<=} (SELECT 字段名 FROM 表名 [WHERE] [GROUP BY] [HAVING] [ORDER BY] [LIMIT]); \"]},\"52\":{\"h\":\"列子查询\",\"t\":[\"返回结果为多行一列数据的子查询。 列子查询常用的运算符：\",\"in 在指定的集合范围之内，多选一\",\"not in 不在指定的集合范围之内\",\"any 子查询返回列表中，有任意一个满足条件的即可\",\"some 与any左右相同\",\"all 子查询返回的所有值都必须满足\",\"SELECT *|字段 FROM 表名 WHERE 字段名{IN|NOT IN|ANY|SOME|ALL} (SELECT 字段名 FROM 表名 [WHERE] [GROUP BY] [HAVING] [ORDER BY] [LIMIT]); \"]},\"53\":{\"h\":\"行子查询\",\"t\":[\"返回结果为一行多列数据的子查询。\",\"SELECT *|{字段名[, ...]} FROM 表名 WHERE {指定字段名1, 指定字段名2, ...} {=|<>|IN|NOT IN} (SELECT 字段名[, ...] FROM 表名[WHERE] [GROUP BY] [HAVING] [ORDER BY] [LIMIT]); \"]},\"54\":{\"h\":\"表子查询\",\"t\":[\"返回结果为多行多列数据的子查询。 表子查询多位于FROM关键字之后,将查询到的数据当作数据源。\",\"SELECT *|字段名[, ...] FROM (表子查询) [AS] 别名 [WHERE] [GROUP BY] [HAVING] [ORDER BY] [LIMIT]; \"]},\"55\":{\"h\":\"EXISTS子查询\",\"t\":[\"用于判断满足给定条件的记录是否存在。\",\"SELECT *|字段名[, ...] FROM 表名 WHERE EXISTS (SELECT * FROM 表名 [WHERE] [GROUP BY] [HAVING] [ORDER BY] [LIMIT]); \"]},\"56\":{\"h\":\"数据库、数据表基操\"},\"57\":{\"h\":\"创建与查看\",\"t\":[\"SQL根据功能分为了\",\"DQL 数据查询语言\",\"DML 数据操作语言\",\"DDL 数据定义语言\",\"DCL 数据控制语言\",\"1、select和insert 2、update和delete 3、create和alter和drop 创建、修改、删除 4、grant和commit和rollback 用户授权、提交事务、回滚事务\"]},\"58\":{\"h\":\"Tip:\",\"t\":[\"在Windows平台下，数据库名、数据表名和字段名都不区分大小写。 在Linux平台下，数据库名和数据表名严格区分大小写，字段名不区分大小写。 关键字不区分大小写，习惯上使用大写，用户自定义的名称习惯上使用小写。 SQL语句可以在单行或多行中书写，以分号结束即可。 关键字不能直接作为用户自定义名称使用，如果要使用可以通过反引号包裹，如\",\"`select` \",\"[]：表示可选项,里面的参数可有可无 {}中使用“|” ：表示选择项，在选择项中仅需选择其中一项\",\"-- 单行注释 # 单行注释 /* 多行注释 */ \",\"字符编码：计算机采用二进制方式保存数据，用户输入的字符会按照一定的规则转换为二进制后保存。 校对集：用于为不同字符集指定比较和排序规则，在进行比较和排序等操作时都会用到校对集。 例如，utf8mb4字符集默认的校对集为utf8mb4_0900_ai_ci。\",\"常用的字符编码是：utf8中的单个字符最多占用3个字节，utf8mb4中的单个字符允许占用4个字节，如果要在数据库中使用emoji表情，需要选择utf8mb4字符集。\"]},\"59\":{\"h\":\"创建\",\"t\":[\"CREATE {DATABASE|SCHEMA} [IF NOT EXISTS] 数据库名称 [DEFAULT CHARSET][COLLATE]; -- CREATE {DATABASE|SCHEMA}：表示创建数据库，DATABASE和SCHEMA都表示数据库。 -- IF NOT EXISTS：可选项，创建数据库前判断要创建的数据库的名称是否已经存在。 -- DEFAULT CHARSET：可选项，指定数据库字符集，如果省略使用默认字符集。 -- COLLATE：可选项，指定校对集，省略使用字符集对应的默认校对集。 \"]},\"60\":{\"h\":\"查看\",\"t\":[\"-- 查看所有数据库的基本语法： SHOW {DATABASES|SCHEMAS} [LIKE 'pattern'|WHERE expr]; -- SHOW {DATABASES|SCHEMAS}：使用SHOW DATABASES或SHOW SCHEMAS查看已存在的数据库。 -- LIKE ‘pattern’：可选项，根据指定的匹配模式匹配数据库，通过“%”和“_”指定匹配模式，%表示匹配一个或多个字符；_表示匹配一个字符。 -- WHERE expr：可选项，根据指定条件匹配数据库。 \"]},\"61\":{\"h\":\"Tip\",\"t\":[\"MySQL自动创建的4个数据库的作用： information_schema 主要存储数据库和数据表的结构信息，如用户表信息、字段信息、字符集信息。 mysql 主要存储MySQL自身需要使用的控制和管理信息，如用户的权限。 performance_schema 用于存储系统性能相关的动态参数，如全局变量。 sys 系统数据库，包括了存储过程、自定义函数等信息。\",\"-- school只是实例 -- 查看指定数据库的创建信息基本语法： SHOW CREATE {DATABASE|SCHEMA} 数据库名称; \",\"标准的一条建库语句\",\"create database school character set utf8mb4 collate utf8mb4_general_ci; \",\"-- 查看建库语句。school只是实例 show create database school \"]},\"62\":{\"h\":\"Tip\",\"t\":[\"数据类型：\",\"整数 tinyint,smallint,mediumint,int,bigint\",\"浮点数 用于保存小数。 float(4字节),double(8字节)\",\"定点数 用于保存确切精度的小数。 decimal,numberic\",\"字符串类型 char,varchar,tinyblob,blob,mediumblob longblob,tinytext,text,mediumtext,longtext\",\"日期和时间 year,date,time,datetime,timestamp\",\"浮点数类型的精度不高，浮点数类型适合将小数作为近似值存储而不是作为精确值存储。 FLOAT类型的数字，整数和小数超过6位就有可能损失精度。 DOUBLE类型的数字，整数和小数超过15位就有可能损失精度。 数学计算时浮点数也可能会损失精度。\",\"DECIMAL(M,D) M：整数部分加小数部分的总长度，取值范围0~65，默认值10，超出范围会报错； D：小数部分位数，取值范围0~30，默认值0，且必须满足D<=M。\",\"varchar变长，char固定长度\",\"blob常用来存储图片、pdf文档等二进制数据\",\"MySQL中数据表的单行长度限制为65 535字节。 单行长度限制是指一条记录中除BLOB系列和TEXT系列外的其他常见数据类型的字段加起来不能超过限制。 BLOB系列和TEXT系列的字段不受单行长度限制，只会占用单行的9~12字节的存储空间。\",\"使用YEAR类型时，一定要区分字符**'0'和数字0**。 前者代表2000年，后者代表0000年\",\"TIMESTAMP类型与DATATIME类型的区别： TIMESTAMP类型的取值范围比DATATIME类型小。 TIMESTAMP类型的值和时区有关，两个不同时区取出来的同一个日期和时间的显示结果可能不同。 如插入日期和时间时，系统会根据当前系统所设置的时区，对日期和时间进行转换后存放； 从获取日期和时间时，会将数据转换为对应时区时间后显示。\"]},\"63\":{\"h\":\"选择数据库\",\"t\":[\"USE 数据库名称;\"]},\"64\":{\"h\":\"建表语句\",\"t\":[\"CREATE [TEMPORARY] TABLE [IF NOT EXISTS] 表名 ( 字段名 数据类型 [字段属性]... ) [表选项]; -- TEMPORARY：可选项，表示临时表，临时表仅在当前会话可见，会话结束后自动删除。 -- IF NOT EXISTS：可选项，只有在创建的数据表不存在时，才会创建数据表。 -- 表名：数据表的名称。 -- 字段名：字段的名称。 -- 数据类型：字段的数据类型。 -- 字段属性：可选项，设置COMMENT属性给字段添加备注；设置约束属性保证数据的完整性和有效性。 -- 表选项：可选项，设置数据表的相关选项，如存储引擎、字符集、校对集等。 \"]},\"65\":{\"h\":\"查看所有的存储引擎\",\"t\":[\"show engines; \"]},\"66\":{\"h\":\"查看数据表\",\"t\":[\"通过SHOW TABLES语句查看当前数据库中的数据表。\",\"SHOW TABLES [LIKE 'pattern'|WHERE expr]; -- LIKE子句和WHERE子句为可选项。 -- 如果不添加可选项，表示查看当前数据库中所有的数据表。 -- 如果添加可选项，则按照LIKE子句的匹配结果或者WHERE子句的匹配结果查看数据表。 \"]},\"67\":{\"h\":\"查看建表语句\",\"t\":[\"SHOW CREATE TABLE 表名; \"]},\"68\":{\"h\":\"使用DESC语句查看数据表结构\",\"t\":[\"DESC 表名;\",\"DESC语句返回的信息： Field：数据表中字段的名称，即列的名称。 Type：数据表中字段对应的数据类型。 Null：该字段是否可以存储NULL值。 Key：该字段是否已经建立索引。 Default：该字段是否有默认值。 Extra：字段相关的附加信息。\"]},\"69\":{\"h\":\"修改和删除\"},\"70\":{\"h\":\"修改数据库\",\"t\":[\"ALTER {DATABASE|SCHEMA} [数据库名称] [DEFAULT CHARSET] [COLLATE] [ENCRYPTION] [READ ONLY]; ALTER {DATABASE|SCHEMA} 修改指定名称的数据库 数据库名称 可选项，表示要修改哪个数据库 DEFAULT CHARSET 可选项，用于指定默认的数据库字符集 COLLATE 可选项，用于指定校对集 ENCRYPTION 可选项，用于为数据库加密 READ ONLY 用于控制是否允许修改数据库及其中的数据 \"]},\"71\":{\"h\":\"删除数据库\",\"t\":[\"DROP {DATABASE|SCHEMA} [IF EXISTS] 数据库名称; \"]},\"72\":{\"h\":\"修改数据表名称\",\"t\":[\"ALERT TABLE 旧表名 RENAME [TO|AS] 新表名; or RENAME TABLE 旧表名1 TO 新表名1[, 旧表名2 TO 新表名2] ...; \"]},\"73\":{\"h\":\"修改数据表字段名称\",\"t\":[\"ALTER TABLE 表名 CHANGE [COLUMN] 旧字段名 新字段名 数据类型[字段属性]; -- 旧字段名：修改前的字段名。 -- 新字段名：修改后的字段名。 -- 数据类型：修改后字段的数据类型，不能为空，即使新字段的数据类型与旧字段的数据类型相同，也必须设置。 or ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名; \"]},\"74\":{\"h\":\"修改数据表中字段的数据类型\",\"t\":[\"ALTER TABLE 表名 CHANGE [COLUMN] 字段名 新数据类型[字段属性]; or ALTER TABLE 表名 MODIFY [COLUMN] 字段名 新数据类型; \"]},\"75\":{\"h\":\"为数据表添加指定字段\",\"t\":[\"-- 添加一个字段 ALTER TABLE 表名 ADD [COLUMN] 新字段名 数据类型 [FIRST|AFTER 字段名]; -- 添加多个字段 ALTER TABLE 表名 ADD [COLUMN] (新字段名1 数据类型1, 新字段名2 数据类型2, ...); -- FIRST参数：将数据表中新字段名添加为数据表的第一个字段。 -- AFTER参数：将新字段添加到指定字段的后面。 -- 若不指定字段添加位置，新字段默认添加到数据表的最后。 \"]},\"76\":{\"h\":\"修改数据表中字段的排列位置\",\"t\":[\"# 语法1，将某个字段修改为表的第一个字段 ALTER TABLE 表名 MODIFY 字段名 数据类型 FIRST; # 语法2，将字段名1移动到字段名2的后面 ALTER TABLE 表名 MODIFY 字段名1 数据类型 AFTER 字段名2; or # 语法1，将某个字段修改为表的第一个字段 ALTER TABLE 表名 CHANGE 字段名 字段名 数据类型 FIRST; # 语法2，将字段名1移动到字段名2的后面 ALTER TABLE 表名 CHANGE 字段名1 字段名1 数据类型 AFTER 字段名2; \"]},\"77\":{\"h\":\"删除数据表中的指定字段\",\"t\":[\"ALTER TABLE 表名 DROP [COLUMN] 字段名1 [, DROP 字段名2] ...; \"]},\"78\":{\"h\":\"删除数据表\",\"t\":[\"DROP [TEMPORARY] TABLE [IF EXISTS] 表名1[, 表名2]...; -- TEMPORARY：可选项，表示删除临时表。 -- IF EXISTS：可选项，表示在删除之前判断数据表是否存在。 \"]},\"79\":{\"h\":\"数据库的约束\"},\"80\":{\"h\":\"非空约束\",\"t\":[\"非空约束用于确保插入到字段中值的非空性。 字段设置非空约束后，该字段存放的值必须是NULL值之外的其他的具体值。 非空约束通过NOT NULL来实现，在数据表中可以为多个字段同时设置非空约束。 非空约束可以在创建数据表时设置，也可以在修改数据表时设置。\",\"创建数据表时设置\",\"CREATE TABLE 表名 ( 字段名 数据类型 NOT NULL ); \",\"修改数据表时设置\",\"# 语法1，MODIFY子句 ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL; # 语法2，CHANGE子句 ALTER TABLE 表名 CHANGE [COLUMN] 字段名 字段名 数据类型 NOT NULL; \",\"删除非空约束 通过ALTER TABLE语句中的MODIFY子句或CHANGE子句以重新定义字段的方式删除非空约束：\",\"# 语法1，MODIFY子句 ALTER TABLE 表名 MODIFY 字段名 数据类型; # 语法2，CHANGE子句 ALTER TABLE 表名 CHANGE [COLUMN] 字段名 字段名 数据类型; \"]},\"81\":{\"h\":\"唯一约束\",\"t\":[\"唯一约束用于确保字段中值的唯一性，设置唯一约束后，该字段中存放的值不能重复出现。 唯一约束通过UNIQUE关键字设置，可以在数据表中设置一个或者多个唯一约束。 唯一约束可以在创建数据表时设置，也可以在修改数据表时设置。\"]},\"82\":{\"h\":\"Tip\",\"t\":[\"创建数据表时设置唯一约束的方式有两种，分别是列级约束和表级约束。 列级约束和表级约束的区别： 列级约束定义在列中，紧跟在字段的数据类型之后，只对该字段起约束作用。 表级约束独立于字段，可以对数据表的单个或多个字段起约束作用。 当表级唯一约束建立在多个字段上时，会通过多个字段确保唯一性，只要多个字段中有一个字段不同，那么结果就是唯一的。 当表级唯一约束仅建立在一个字段上时，其效果与列级约束相同。\",\"创建数据表时设置 列级\",\"CREATE TABLE 表名 ( 字段名1 数据类型 UNIQUE, 字段名2 数据类型 UNIQUE ... ); \",\"表级\",\"CREATE TABLE 表名( 字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型, ... UNIQUE (字段名1, 字段名2) ); \"]},\"83\":{\"h\":\"Tip\",\"t\":[\"给字段设置唯一约束后，MySQL会自动给对应的字段添加唯一索引，使用DESC语句查看表结构时，如果字段的Key列值为UNI，表示给字段添加了唯一约束。\",\"修改数据表时设置\",\"# 语法1，MODIFY子句 ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE; # 语法2，CHANGE子句 ALTER TABLE 表名 CHANGE [COLUMN] 字段名 字段名 数据类型 UNIQUE; # 语法3，ADD子句 ALTER TABLE 表名 ADD UNIQUE (字段); \"]},\"84\":{\"h\":\"删除唯一约束\",\"t\":[\"ALTER TABLE 表名 DROP index 字段名; 字段名是指该表中设置了唯一约束的字段 \"]},\"85\":{\"h\":\"主键约束\",\"t\":[\"主键约束用于将一个或多个字段设置为表的主键。 主键约束相当于非空约束和唯一约束的组合，被约束字段不能出现重复值，也不能出现NULL值。 主键约束通过PRIMARY KEY关键字设置，每个数据表中只能设置一个主键约束。 主键约束可以在创建数据表时设置，也可以在修改数据表时设置。\",\"创建数据表时可以设置列级或者表级的主键约束，列级主键约束只能对单字段设置。 表级主键约束是指对单字段或者多字段设置，为多字段设置主键约束时，会形成复合主键。\",\"创建数据表时设置 列级\",\"CREATE TABLE 表名 ( 字段名 数据类型 PRIMARY KEY, ... ); \",\"表级\",\"CREATE TABLE 表名 ( 字段名1 数据类型, 字段名2 数据类型, ... PRIMARY KEY (字段名1, 字段名2) ); \",\"修改数据表时设置\",\"# 语法1，MODIFY子句 ALTER TABLE 表名 MODIFY 字段名 数据类型 PRIMARY KEY; # 语法2，CHANGE子句 ALTER TABLE 表名 CHANGE [COLUMN] 字段名 字段名 数据类型 PRIMARY KEY; # 语法3，ADD子句 ALTER TABLE 表名 ADD PRIMARY KEY (字段); \"]},\"86\":{\"h\":\"删除主键约束\",\"t\":[\"ALTER TABLE 表名 DROP PRIMARY KEY; \"]},\"87\":{\"h\":\"设置字段自动增长\",\"t\":[\"创建数据表时设置\",\"CREATE TABLE 表名 ( 字段名 数据类型 约束 AUTO_INCREMENT, ... ); \",\"修改数据表时设置\",\"# 语法1，MODIFY子句 ALTER TABLE 表名 MODIFY 字段名 数据类型 AUTO_INCREMENT; # 语法2，CHANGE子句 ALTER TABLE 表名 CHANGE 字段名 字段名 数据类型 AUTO_INCREMENT; \"]},\"88\":{\"h\":\"Tip\",\"t\":[\"使用AUTO_INCREMENT的注意事项： 一个数据表中只能有一个字段设置AUTO_INCREMENT，设置AUTO_INCREMENT字段的数据类型应该是整数类型，且该字段必须设置了唯一约束或主键约束。 如果为自动增长字段插入NULL值，或在插入数据时省略了自动增长字段，则该字段会使用自动增长值；如果插入的是一个具体的值，则不会自动增长值。 默认情况下，设置AUTO_INCREMENT字段的值从1开始自增。如果插入了一个大于自动增长值的具体值，则下次自动增长的值为字段中的最大值加1。 使用DELETE删除数据时，自动增长值不会减少或者填补空缺。\"]},\"89\":{\"h\":\"设置默认值约束\",\"t\":[\"默认值约束用于给数据表中的字段指定默认值，向数据表中插入新记录时，如果没有给这个字段赋值，数据库系统会自动为这个字段插入指定的默认值。 默认值约束通过DEFAULT关键字设置。 默认值约束可以在创建数据表时设置，也可以在修改数据表时设置。 创建数据表时设置\",\"CREATE TABLE 表名( 字段名 数据类型 DEFAULT 默认值, ... ); \",\"修改数据表时设置\",\"# 语法1，MODIFY子句 ALTER TABLE 表名 MODIFY 字段名 数据类型 DEFAULT 默认值; # 语法2，CHANGE子句 ALTER TABLE 表名 CHANGE [COLUMN] 字段名 字段名 数据类型 DEFAULT 默认值; \"]},\"90\":{\"h\":\"删除默认值约束\",\"t\":[\"# 语法1，MODIFY子句 ALTER TABLE表名 MODIFY 字段名 数据类型; # 语法2，CHANGE子句 ALTER TABLE表名 CHANGE [COLUMN] 字段名 字段名 数据类型; \"]},\"91\":{\"h\":\"数据操作\"},\"92\":{\"h\":\"添加数据\"},\"93\":{\"h\":\"单条\",\"t\":[\"添加数据时，如果值的数量或顺序与数据表定义的字段数量或顺序不同，必须指定字段。 指定字段可以是表中的全部字段或部分字段\",\"INSERT [INTO] 表名 (字段名1, 字段名2, ...) {VALUES|VALUE} (值1, 值2, ...); 关键字INTO可以省略，省略后效果相同。 字段名表示需要添加数据的字段名称，字段名的顺序需要与值的顺序一一对应，多个字段名之间使用英文逗号分隔。 VALUES和VALUE表示值，可以任选其一，通常情况下使用VALUES。 值表示字段对应的数据，多个值之间使用英文逗号分隔。 \",\"如果省略字段，那么值的顺序必须和数据表定义的字段顺序相同。\",\"INSERT [INTO] 表名 {VALUES|VALUE} (值1, 值2, ...); \",\"扩展 insert中的set子句\",\"INSERT [INTO] 表名 SET 字段名1=值1[, 字段名2=值2, ...]; \"]},\"94\":{\"h\":\"多条\",\"t\":[\"INSERT INTO 表名 [(字段名1, 字段名2, ...)] {VALUES|VALUE} (第1条记录的值1, 第1条记录的值2, ...), (第2条记录的值1, 第2条记录的值2, ...), ... (第n条记录的值1, 第n条记录的值2, ...); -- 如果未指定字段名，则值的顺序要与数据表的字段顺序一致。 -- 如果指定了字段名，则值的顺序与指定的字段名顺序一致。 \"]},\"95\":{\"h\":\"更新数据\"},\"96\":{\"h\":\"部分\",\"t\":[\"更新部分数据指通过WHERE子句指定更新数据条件，根据条件更新数据表中的一条或者多条数据。\",\"UPDATE 表名 SET 字段名1=值1[, 字段名2=值2, ...] WHERE 条件表达式; -- SET子句用于指定表中要更新的字段名及相应的值。 -- WHERE子句用于指定表中要更新的记录，WHERE后跟指定条件，只有满足了指定条件的记录才会被更新。 -- SET子句中的字段名是要更新的字段名称，值是字段被更新后的值。如果想要在原字段值的基础上更新，可以使用加（+）、减（-）、乘（*）、除（/）运算符。 -- 例如，age的值是18，“age+1”表示在原基础上加1，结果为19。 \"]},\"97\":{\"h\":\"全部\",\"t\":[\"使用UPDATE语句更新数据时，如果不添加WHERE子句，则会将表中所有数据的指定字段全部更新。\",\"UPDATE 表名 SET 字段名1=值1[, 字段名2=值2, ...]; -- SET子句用于指定表中要修改的字段名及相应的值。其中，字段名是要修改的字段的名称，值为相应字段名被修改后的值。 \"]},\"98\":{\"h\":\"删除数据\"},\"99\":{\"h\":\"部分\",\"t\":[\"使用DELETE语句可以删除部分数据，通过WHERE子句可以指定删除数据的条件。\",\"DELETE FROM 表名 WHERE 条件表达式; 表名是要删除的数据表名称 WHERE子句用于设置删除的条件，满足条件的数据会被删除 \"]},\"100\":{\"h\":\"全部\",\"t\":[\"使用DELETE语句可以删除数据表中的全部数据，在使用时省略WHERE子句即可\",\"DELETE FROM 表名; \"]},\"101\":{\"h\":\"使用TRUNCATE语句来删除数据表中所有的数据\",\"t\":[\"TRUNCATE [TABLE] 表名; -- 如果字段值设置了AUTO_INCREMENT属性： -- 使用TRUNCATE删除数据后，再次添加数据时，该字段的值是从1开始自增。 -- 使用DELETE语句删除数据，字段值不会从1开始自增，而是保持原有的自动增长值。 \"]},\"102\":{\"h\":\"索引\",\"t\":[\"索引是一种单独的、物理的存储结构，为数据表创建索引可以快速找到目标数据，也可以对数据表中一列或多列的值进行排序。\"]},\"103\":{\"h\":\"Tip\",\"t\":[\"常见的索引：普通，唯一性，主键，全文，空间 普通索引是MySQL中的基本索引类型，使用KEY或INDEX关键字定义，不需要添加任何限制条件。\",\"唯一性索引用于限制字段不能出现重复值时，在创建唯一约束时，唯一性索引会被自动创建。 创建唯一性索引的字段允许有NULL值，且NULL值不会被视为重复值。\",\"主键索引用于根据主键自身的唯一性标识每一条记录。在创建主键约束时，主键索引会被自动创建。主键索引的字段不允许有NULL值。\",\"全文索引主要用于提高数据量较大的字段的查询效率。全文索引只能创建在CHAR、VARCHAR或TEXT类型的字段上。\",\"空间索引只能创建在空间数据类型的字段上，空间数据类型存储的空间数据是指含有位置、大小、形状以及自身分布特征的数据。 创建空间索引的字段，必须将其声明为NOT NULL。\",\"根据创建索引的字段个数分类： 单列索引 复合索引\",\"单列索引是在表中单个字段上创建索引，它可以是普通索引、唯一索引或者全文索引，只要保证该索引只对应表中一个字段即可。\",\"复合索引是指在多个字段上创建索引，字段的设置遵循“最左前缀”原则，把使用频率最高的字段放在索引字段列表的最左边。当查询条件中使用这些字段中的第一个字段时，该索引就会被使用。\",\"虽然索引可以提高数据的查询速度，但同时索引会占用一定的磁盘空间，并且在创建和维护索引时，其消耗的时间是随着数据量的增加而增加的。因此，使用索引时需要综合考虑索引的优点和缺点。\",\"为数据表建立事务以确保一组SQL语句操作数据的完整性。 为数据表建立视图以提高数据的安全性。 为数据表建立索引以加快数据的查询效率。\"]},\"104\":{\"h\":\"索引的使用\"},\"105\":{\"h\":\"创建\"},\"106\":{\"h\":\"再创建数据表的同时创建索引\",\"t\":[\"CREATE TABLE 表名( 字段名 数据类型 [字段属性], ... {INDEX|KEY} [索引名] [索引类型] (字段列表) | UNIQUE [INDEX|KEY] [索引名] [索引类型] (字段列表) | PRIMARY KEY [索引类型] (字段列表) | {FULLTEXT|SPATIAL} [INDEX|KEY] [索引名] (字段列表) ); -- {INDEX|KEY}：INDEX和KEY为同义词，表示索引，二者选一即可。 -- 索引名：可选项，表示为创建的索引定义的名称，不使用该选项时，单列索引默认使用建立索引的字段表示，复合索引默认使用第一个字段的名称表示。 -- 索引类型：可选项，不同的存储引擎允许在创建索引时指定索引类型，语法是USING {BTREE | HASH}，例如InnoDB和MyISAM支持BTREE，MEMORY支持BTREE和HASH。 -- UNIQUE：可选项，表示唯一性索引。 -- FULLTEXT：可选项，表示全文索引。 -- SPATIAL：可选项，表示空间索引。 \"]},\"107\":{\"h\":\"为已有的数据表创建索引\",\"t\":[\"CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX 索引名 [索引类型] ON 表名 (字段列表); \"]},\"108\":{\"h\":\"修改数据表的同时创建索引\",\"t\":[\"ALTER TABLE 表名 ADD {INDEX|KEY} [索引名] [索引类型] (字段列表) | ADD UNIQUE [INDEX|KEY] [索引名] [索引类型] (字段列表) | ADD PRIMARY KEY [索引类型] (字段列表) | ADD {FULLTEXT|SPATIAL} [INDEX|KEY] [索引名] (字段列表); \"]},\"109\":{\"h\":\"查看索引\",\"t\":[\"-- 也可以使用SHOW CREATE TABLE语句，查看建表语句的同时也可以看到索引信息 SHOW {INDEXES|INDEX|KEYS} FROM 表名; -- 查看索引的结果中每个字段的含义： -- Table 索引所在的数据表的名称 -- Non_unique 索引是否可以重复，0不可以，1可以 -- Key_name 索引的名称，如果索引为主键索引，那么名称为PRIMARY -- Seq_in_index 建立索引的字段序号值，默认从1开始 -- Column_name 建立索引的字段 -- Collation 索引字段是否有排序，A有,NULL没有 -- Cardinality MySQL连接时使用索引的可能性，值越大可能性越高 -- Sub_part 前缀索引的长度，如字段值都被索引则Sub_part为NULL -- Packed 关键词如何被压缩，如果没有被压缩为NULL -- Null 索引字段是否含有NULL值 -- Index type 索引方式，可选值为:FULLTEXT,HASH,BTREE,RTREE -- Comment 索引字段的注释信息 -- Index comment 创建索引时添加的注释信息 -- Visible 索引对查询优化器是否可见 -- Expression 使用什么表达式作为建立索引的字段 \"]},\"110\":{\"h\":\"分析SQL是否使用索引\",\"t\":[\"使用EXPLAIN命令分析执行的SQL语句是否使用了索引 eg:explain select * from employee where dept_id=132;\"]},\"111\":{\"h\":\"删除索引\",\"t\":[\" ALTER TABLE 表名 DROP INDEX 索引名; or DROP INDEX 索引名 ON 表名; -- 删除主键索引时，主键索引的索引名应使用PRIMARY，PRIMARY使用反引号“`”包括。 # 语法1 ALTER TABLE 表名 DROP INDEX `PRIMARY`; # 语法2 DROP INDEX `PRIMARY` ON 表名; \"]},\"112\":{\"h\":\"视图\",\"t\":[\"定义： 视图是一种虚拟存在的表，视图的数据来源于数据库中的数据表，这些数据表被称为基本表。 通过视图不仅可以看到基本表中的数据，还可以对基本表中的数据进行添加、修改和删除。 数据库中只保存定义视图的SQL语句，不保存视图对应的数据。 当基本表中的数据发生变化时，视图中查询出来的数据也会随之改变，当通过视图修改数据时，基本表中的数据也会发生变化。\",\"优点：不仅可以简化用户对数据的理解，还可以简化对数据的操作等等。\"]},\"113\":{\"h\":\"基于单表的视图\"},\"114\":{\"h\":\"创建\",\"t\":[\" CREATE [OR REPLACE] [ALGORITHM = {MERGE | TEMPTABLE | UNDEFINED}] [DEFINER = user] [SQL SECURITY { DEFINER | INVOKER }] VIEW 视图名 [(字段列表)] AS select_statement; [WITH [CASCADED | LOCAL] CHECK OPTION]; -- OR REPLACE：可选，若数据库中已存在这个名称的视图就替换原有视图，若不存在则创建视图。 -- ALGORITHM子句：用于声明MySQL处理视图的方式，MERGE表示将引用视图的语句和定义视图的语句合并，TEMPTABLE表示将视图的结果保存到临时表，UNDEFINED表示未指定处理方式（默认使用MERGE）。 -- DEFINER子句和SQL SECURITY子句：用于声明执行视图时的访问权限，DEFINER子句中的user值通常为“'用户名'@'主机地址'”、CURRENT_USER或CURRENT_USER()，如果省略DEFINER子句，默认执行者为创建视图的用户。 -- 视图名：表示要创建的视图名称，该名称在数据库中必须是唯一的，不能与其他数据表或视图同名。 -- select_statement：指一个完整的SELECT语句，表示从某个数据表或视图中查出满足条件的记录，将这些记录导入视图中。 -- WITH CHECK OPTION：可选，用于视图数据操作时的检查条件，若省略，则不进行检查，它的取值有CASCADED（默认），操作数据时满足所有有关视图和表定义的条件；LOCAL，操作数据时只需要满足该视图本身定义的条件。 \"]},\"115\":{\"h\":\"基于多表的视图\"},\"116\":{\"h\":\"创建\",\"t\":[\"基于两张或者两张以上的数据表创建视图，这种视图被称为基于多表的视图。创建基于多表的视图时，只需要将CREATE VIEW语句中的SELECT语句指定为多表查询的SQL语句即可。\"]},\"117\":{\"h\":\"查看视图\",\"t\":[\"为了充分了解某个视图的信息，需要查看视图的字段、状态、创建语句\"]},\"118\":{\"h\":\"查看视图的字段信息\",\"t\":[\"DESCRIBE 视图名; -- 简写 DESC 视图名; \"]},\"119\":{\"h\":\"查看视图的状态信息\",\"t\":[\"SHOW TABLE STATUS LIKE '视图名'; \"]},\"120\":{\"h\":\"查看视图的创建语句\",\"t\":[\"SHOW CREATE VIEW 视图名; \"]},\"121\":{\"h\":\"修改视图\",\"t\":[\"-- 方式一 CREATE OR REPLACE VIEW 视图名 AS SELECT语句; -- 方式二 ALTER VIEW 视图名 AS SELECT语句; \"]},\"122\":{\"h\":\"通过视图来操作数据\",\"t\":[\"通过视图操作基本表的方式与直接操作数据表的方式一样(insert,update,delete) eg:\",\"insert into 视图名 value(xx,xx,xx); \"]},\"123\":{\"h\":\"删除视图\",\"t\":[\"删除视图时只会删除所创建的视图，不会删除基本表中的数据。\",\"DROP VIEW 视图名1 [, 视图名2, …]; \"]},\"124\":{\"h\":\"前言\",\"t\":[\"总共有12个都是直接挂在Vue上的方法叫做全局api分别为:\",\"extend\",\"语法:\",\"Vue.extend(options)\",\"参数:\",\"{Object}options\",\"作用:\",\"使用基础Vue构造器，创建一个子类，参数是一个包含组件选项的对象\",\"注意:\",\"data选项是特例，需要注意在Vue.extend中它必须是函数\",\"示例:\",\" <div id=\\\"mount-point\\\"></div> \",\"<!-- 创建构造器 --> var Profile=Vue.extend({ template:'<p>{{firstName}}{{lastName}} aka {{alias}}</p>', data:function(){ return{ firstName:\\\"Walter\\\", lastName:\\\"White\\\", alias:\\\"Heisenberg\\\" } } }) <!-- 创建Profile实例，并挂载到一个元素上 --> new Profile().$mount(\\\"#mount-point\\\") \",\" <p>Walter White aka Heisenberg</p> \",\"原理分析\",\"Vue.extend的作用是创建一个继承Vue类的子类,可接受的参数是一个包含组件选项的对象\",\"整个过程就是先创建一个类Sub,接着通过原型继承的方式将该类继承基础Vue类，然后给Sub类添加一些属性以及将父类的某些属性复制到Sub类上，最后将Sub类返回\",\"源码\",\" Vue.extend = function (extendOptions: Object): Function { extendOptions = extendOptions || {} const Super = this const SuperId = Super.cid const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {}) if (cachedCtors[SuperId]) { return cachedCtors[SuperId] } const name = extendOptions.name || Super.options.name if (process.env.NODE_ENV !== 'production' && name) { validateComponentName(name) } const Sub = function VueComponent (options) { this._init(options) } Sub.prototype = Object.create(Super.prototype) Sub.prototype.constructor = Sub Sub.cid = cid++ Sub.options = mergeOptions( Super.options, extendOptions ) Sub['super'] = Super if (Sub.options.props) { initProps(Sub) } if (Sub.options.computed) { initComputed(Sub) } // allow further extension/mixin/plugin usage Sub.extend = Super.extend Sub.mixin = Super.mixin Sub.use = Super.use // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) { Sub[type] = Super[type] }) // enable recursive self-lookup if (name) { Sub.options.components[name] = Sub } Sub.superOptions = Super.options Sub.extendOptions = extendOptions Sub.sealedOptions = extend({}, Sub.options) // cache constructor cachedCtors[SuperId] = Sub return Sub } \",\"nextTick\",\"语法:\",\"Vue.nextTick([callback,context])\",\"参数:\",\"{Function} [callback] {Object}[context]\",\"作用:\",\"在下次DOM更新循环结束后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM\",\"示例\",\" // 修改数据 vm.msg = 'Hello' // DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示) Vue.nextTick() .then(function () { // DOM 更新了 }) \",\"提示\",\"2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\",\"原理分析:\",\"该API的原理同实例方法 $nextTick原理一样，此处不再重复。唯一不同的是实例方法 $nextTick 中回调的 this 绑定在调用它的实例上。\",\"set\",\"语法:\",\"Vue.set(target,propertyName/index,value)\",\"参数:\",\"{Object|Array} target\",\"{string | number} propertyName/index\",\"{any} value\",\"返回值:设置的值\",\"作用:\",\"向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为Vue无法探测普通的新增属性(比如:this.myObject.newPerperty='hi')\",\"原理分析:\",\"该API的原理同实例方法$set原理一样\",\"delete\",\"语法:\",\"Vue.delete(target,propertyName/index)\",\"参数:\",\"{Object | Array} target\",\"{string | number} propertyName/index\",\"提示\",\"2.2.0+版本中支持Array+index用法\",\"作用\",\"删除对象的属性。如果对象是响应式的，确保删除能触发更新视图.这个方法主要用于避开Vue不能检测到属性被删除的限制，但是你应该很少会使用它\",\"提示\",\"2.2.0+版本中支持在数组上工作\",\"原理分析\",\"该API的原理同实例方法 $delete原理一样\",\"directive\",\"语法:\",\"Vue.directive(id,[definition])\",\"参数:\",\"{string}id\",\"{Function | Object}[definition]\",\"作用\",\"注册或获取全局指令\",\" // 注册 Vue.directive('my-directive', { bind: function () {}, inserted: function () {}, update: function () {}, componentUpdated: function () {}, unbind: function () {} }) // 注册 (指令函数) Vue.directive('my-directive', function () { // 这里将会被 `bind` 和 `update` 调用 }) // getter，返回已注册的指令 var myDirective = Vue.directive('my-directive') \",\"原理分析\",\"从用法中可以知道,该API是用来注册或获取全局指令的，接受两个参数:指令id和指令的定义\",\"注册指令是将定义好的指令存放在某个位置，获取指令是根据指令id从存放指令的位置来读取指令\",\"该API的内部实现原理\",\" Vue.options = Object.create(null) Vue.options['directives'] = Object.create(null) Vue.directive= function (id,definition) { if (!definition) { return this.options['directives'][id] } else { if (type === 'directive' && typeof definition === 'function') { definition = { bind: definition, update: definition } } this.options['directives'][id] = definition return definition } } \",\"可以看到，我们在Vue类上创建了options属性，其属性值为一个空对象，并且在options属性中添加了directives属性，其值也是一个空对象，这个directives属性就是用来存放指令的位置。如下：\",\" Vue.options = Object.create(null) Vue.options['directives'] = Object.create(null) \",\"该API可以用来注册或获取全局指令，这两种功能的切换取决于是否传入了definition参数。如果没有传入definition参数，则表示为获取指令，那么从存放指令的地方根据指令id来读取指令并返回\",\" if (!definition) { return this.options['directives'][id] } \",\"如果传入了definition参数，则表示为注册指令，那么继续判断definition参数是否是一个函数，如果是函数，则默认监听bind和update两个事件，即将definition函数分别赋给bind和update两个属性。如下：\",\"if (type === 'directive' && typeof definition === 'function') { definition = { bind: definition, update: definition } } } \",\"如果definition参数不是一个函数，那么即认为它是用户自定义的指令对象，直接将其保存在this.options['directives']中，如下：\",\" this.options['directives'][id] = definition \",\"filter\",\"语法:\",\"Vue.filter(id,[definition])\",\"参数:\",\"{string} id\",\"{Function} [definition]\",\"作用:\",\"注册或获取全局过滤器\",\" // 注册 Vue.filter('my-filter', function (value) { // 返回处理后的值 }) // getter，返回已注册的过滤器 var myFilter = Vue.filter('my-filter') \",\"原理分析\",\"该API是用来注册或获取全局过滤器的，接收两个参数：过滤器id和过滤器的定义。\",\"同全局指令一样，注册过滤器是将定义好的过滤器存放在某个位置，获取过滤器是根据过滤器id从存放过滤器的位置来读取过滤器。\",\"源码如下\",\" Vue.options = Object.create(null) Vue.options['filters'] = Object.create(null) Vue.filter= function (id,definition) { if (!definition) { return this.options['filters'][id] } else { this.options['filters'][id] = definition return definition } } \",\"可以看到，同全局指令一样，Vue.options['filters']是用来存放全局过滤器的地方。还是根据是否传入了definition参数来决定本次操作是注册过滤器还是获取过滤器。如果没有传入definition参数，则表示本次操作为获取过滤器，那么就从存放过滤器的地方根据过滤器id来读取过滤器并返回；如果传入了definition参数，则表示本次操作为注册过滤器，那就直接将其保存在this.options['filters']中。\",\"component\",\"语法:\",\"Vue.component(id,[definition])\",\"参数:\",\"{string} id\",\"{Function | Object} [definition]\",\"作用:\",\"注册或获取全局组件,注册还会自动使用给定的id设置组件的名称\",\" // 注册组件，传入一个扩展过的构造器 Vue.component('my-component', Vue.extend({ /* ... */ })) // 注册组件，传入一个选项对象 (自动调用 Vue.extend) Vue.component('my-component', { /* ... */ }) // 获取注册的组件 (始终返回构造器) var MyComponent = Vue.component('my-component') \",\"源码分析\",\"该API是用来注册或获取全局组件的，接收两个参数：组件id和组件的定义。\",\"同全局指令一样，注册全局组件是将定义好的组件存放在某个位置，获取组件是根据组件id从存放组件的位置来读取组件。\",\"源码:\",\" Vue.options = Object.create(null) Vue.options['components'] = Object.create(null) Vue.filter= function (id,definition) { if (!definition) { return this.options['components'][id] } else { if (process.env.NODE_ENV !== 'production' && type === 'component') { validateComponentName(id) } if (type === 'component' && isPlainObject(definition)) { definition.name = definition.name || id definition = this.options._base.extend(definition) } this.options['components'][id] = definition return definition } } \",\"同全局指令一样，Vue.options['components']是用来存放全局组件的地方。还是根据是否传入了definition参数来决定本次操作是注册组件还是获取组件。如果没有传入definition参数，则表示本次操作为获取组件，那么就从存放组件的地方根据组件id来读取组件并返回；如果传入了definition参数，则表示本次操作为注册组件，如果是注册组件，那么在非生产环境下首先会校验组件的name值是否合法，如下：\",\" if (process.env.NODE_ENV !== 'production' && type === 'component') { validateComponentName(id) } \",\"接着，判断传入的definition参数是否是一个对象，如果是对象，则使用Vue.extend方法将其变为Vue的子类，同时如果definition对象中不存在name属性时，则使用组件id作为组件的name属性。如下：\",\" if (type === 'component' && isPlainObject(definition)) { definition.name = definition.name || id definition = this.options._base.extend(definition) } \",\"最后，将注册好的组件保存在this.options['components']中。 directive,filter,component小结: 通过对Vue.directive、Vue.filter和Vue.component这三个API的分析，细心的你肯定会发现这三个API的代码实现非常的相似，是的，这是我们为了便于理解故意拆开的，其实在源码中这三个API的实现是写在一起的，位于源码的src/core/global-api/index,js和src/core/global-api/assets,js中，如下：\",\" export const ASSET_TYPES = [ 'component', 'directive', 'filter' ] Vue.options = Object.create(null) ASSET_TYPES.forEach(type => { Vue.options[type + 's'] = Object.create(null) }) ASSET_TYPES.forEach(type => { Vue[type] = function (id,definition) { if (!definition) { return this.options[type + 's'][id] } else { if (process.env.NODE_ENV !== 'production' && type === 'component') { validateComponentName(id) } if (type === 'component' && isPlainObject(definition)) { definition.name = definition.name || id definition = this.options._base.extend(definition) } if (type === 'directive' && typeof definition === 'function') { definition = { bind: definition, update: definition } } this.options[type + 's'][id] = definition return definition } } }) \",\"use\",\"语法:\",\"Vue.use(plugin)\",\"参数:\",\"{Object | Function} plugin\",\"作用:\",\"安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。该方法需要在调用 new Vue() 之前被调用。当 install 方法被同一个插件多次调用，插件将只会被安装一次。\",\"原理分析\",\"，该API是用来安装Vue.js插件的。并且我们知道了，该API内部会调用插件提供的install 方法，同时将Vue 作为参数传入。另外，由于插件只会被安装一次，所以该API内部还应该防止 install 方法被同一个插件多次调用。下面我们就来看一下该API的内部实现原理。\",\" Vue.use = function (plugin) { const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) > -1) { return this } // additional parameters const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args) } else if (typeof plugin === 'function') { plugin.apply(null, args) } installedPlugins.push(plugin) return this \",\"}\",\"可以看到，在该函数内部，首先定义了一个变量installedPlugins,该变量初始值是一个空数组，用来存储已安装过的插件。首先判断传入的插件是否存在于installedPlugins数组中（即已被安装过），如果存在的话，则直接返回，防止重复安装。如下： ```js const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) > -1) { return this } \",\"接下来获取到传入的其余参数，并且使用toArray方法将其转换成数组，同时将Vue插入到该数组的第一个位置，这是因为在后续调用install方法时，Vue必须作为第一个参数传入。如下：\",\" const args = toArray(arguments, 1) args.unshift(this) \",\"在用法回顾中说了，传入的插件可以是一个提供了 install 方法的对象。也可以是一个函数，那么这个函数会被作为 install 方法。所以在接下来会根据这两种不同的情况分别处理。 首先，判断传入的插件如果是一个提供了 install 方法的对象，那么就执行该对象中提供的 install 方法并传入参数完成插件安装。如下：\",\" if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args) } \",\"如果传入的插件是一个函数，那么就把这个函数当作install方法执行，同时传入参数完成插件安装。如下：\",\" else if (typeof plugin === 'function') { plugin.apply(null, args) } \",\"插件安装完成之后，将该插件添加进已安装插件列表中，防止重复安装。如下： 9. mixin - 语法: - Vue.mixin(mixin) - 参数: - {Object} mixin - 作用: - 全局注册一个混入，影响之后所有创建的每个Vue实例。插件作者可以使用混入，向组件注入自定义行为。不推荐在应用代码中使用 - 原理分析 - 该API是用来向全局注册一个混入，即可以修改Vue.options属性，并且会影响之后的所有Vue实例，这个API虽然在日常的业务开发中几乎用不到，但是在编写Vue插件时用处非常大。下面我们就来看一下该API的内部实现原理。 js Vue.mixin = function (mixin: Object) { this.options = mergeOptions(this.options, mixin) return this } 可以看到，该API的实现非常简单。因为上文中我们说了，该API就是通过修改Vue.options属性进而影响之后的所有Vue实例。所以我们只需将传入的mixin对象与this.options合并即可，然后将合并后的新对象作为this.options传给之后的所有Vue实例，从而达到改变其原有特性的效果。\",\"compile \",\"语法:\",\"Vue.compile(template)\",\"{string} template\",\"作用:\",\"在render函数中编译模板字符串。只在独立构建时有效\",\" var res = Vue.compile('<div><span>{{ msg }}</span></div>') new Vue({ data: { msg: 'hello' }, render: res.render, staticRenderFns: res.staticRenderFns }) \",\"原理分析\",\"该API是用来编译模板字符串的，我们在日常业务开发中几乎用不到，它内部是调用了compileToFunctions方法，如下：\",\" Vue.compile = compileToFunctions; \",\"关于compileToFunctions方法在模板编译篇已经做了非常详细的介绍，此处不再重复。 11. observable - 语法: - Vue.observable( object ) - 参数: - {Object} object - 作用 - 让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：\",\"```js const state = Vue.observable({ count: 0 }) const Demo = { render(h) { return h('button', { on: { click: () => { state.count++ }} }, 'count is:'+state.count) } } ``` - 原理分析 - 从用法回顾中可以知道，该API是用来将一个普通对象转化成响应式对象。在日常业务开发中也几乎用不到，它内部是调用了observe方法，关于该方法在数据变化侦测篇已经做了非常详细的介绍，此处不再重复。 \",\"version \",\"语法\",\"Vue.version\",\"提示\",\"提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。 \",\"用法:\",\" var version = Number(Vue.version.split('.')[0]) if (version === 2) { // Vue v2.x.x } else if (version === 1) { // Vue v1.x.x } else { // Unsupported versions of Vue } \",\"从用法回顾中可以知道，该API是用来标识当前构建的Vue.js的版本号，对于日常业务开发几乎用不到，但是对于插件编写非常有用，可以根据Vue版本的不同从而做一些不同的事情。\\n\\n该API是在构建时读取了package.json中的version字段，然后将其赋值给Vue.version。\\n\"]},\"125\":{\"h\":\"\"},\"126\":{\"h\":\"数据驱动视图\",\"t\":[\"UI=render(state) UI是页面 state是数据\"]},\"127\":{\"h\":\"响应式(变化侦听)\"},\"128\":{\"h\":\"对象的响应式\",\"t\":[\"对象的响应式是通过Object.defineProperty实现 通过一个oberver类来将一个对象转换为响应式(通过递归来将对象中的每一个属性添加setter,getter同时为每一个处理过的对象打上标识符**ob**，避免重复操作)\"]},\"129\":{\"h\":\"依赖收集\",\"t\":[\"将用到该数据的地方，收集起来好进行更新操作\"]},\"130\":{\"h\":\"何时收集？\",\"t\":[\"在该数据的getter中收集\"]},\"131\":{\"h\":\"何时通知依赖更新？\",\"t\":[\"在该数据的setter中通知更新\"]},\"132\":{\"h\":\"收集好的依赖放置在何处？\",\"t\":[\"依赖收集时一个数据有多个依赖者所以通过依赖管理器Dep(Dep类) Dep初始一个subs数组用来保存依赖并提供了(删除，新增，通知依赖的方法)可以在getter中新增在setter中通知\"]},\"133\":{\"h\":\"何为依赖？\",\"t\":[\"Vue中提供Watcher(类)为每一个依赖创建一个Watcher实例数据再变化时就通知对应的Watcher由该实例通知对应的依赖当创建Watcher实例时会把自己添加到这个依赖管理器中\"]},\"134\":{\"h\":\"如何将自己添加到对应的管理器中？\",\"t\":[\"在Watcher的构造函数中，调用this.get()在该方法中通过window.target=this将实例自身赋给一个全局对象然后通过let value=this.getter.call(vm,vm)获取一下被依赖的数据(目的为了触发getter收集在window.target上的值并存入依赖数组中)然后释放window.target，这样当数据变化时，触发setter更新(dep中的通知)遍历依赖(watcher)的update方法从而更新页面\"]},\"135\":{\"h\":\"数组的响应式\"},\"136\":{\"h\":\"为什么对象和数组是两个分开实现？\",\"t\":[\"对象的响应式是通过js原生提供的对象方法实现\"]},\"137\":{\"h\":\"何时收集？\",\"t\":[\"还是在getter中收集 原因： 因为返回的是一个对象，只要是对象里面所有属性都有getter和setter\"]},\"138\":{\"h\":\"何时通知依赖更新？\",\"t\":[\"对象是通过setter来实现对数据进行了操作，那么数组中可改变数据的方法也是对数据进行了操作，那么这些方法称为数组的\\\"setter\\\"，只要对这些方法进行封装即可\"]},\"139\":{\"h\":\"数组方法拦截器\",\"t\":[\"用来拦截数组实例与Array.prototype之间让数组实例访问的是自己封装的方法(原数组的操作没有变化只是添加了一些功能) 通过把数据的__proto__属性改为拦截器就挂载到实例和Array.prototype之间\",\"data(){ return { arr:['1','2'] } } \"]},\"140\":{\"h\":\"依赖收集到哪里？\",\"t\":[\"observer类中，将依赖收集到Dep管理器中\"]},\"141\":{\"h\":\"不足之处\",\"t\":[\"如果给一个对象新增一个属性或删除Vue是监测不到就意味着该属性不具备响应式 如果给一个且通过下表来操作数组元素那么Vue也监测不到不具备响应式\"]},\"142\":{\"h\":\"解决方案\",\"t\":[\"Vue提供了Vue.set和Vue.delete来解决\"]},\"143\":{\"h\":\"何为模板编译?\",\"t\":[\"将用户写在template标签中的类似Html内容解析成为Html内容的过程 也可以说模板编译就是把用户写的模板经过一系列处理最终生成render函数的过程\",\"有了模板编译才有VNode\",\"为什么说是类似html内容? 因为template中除了有html标签还有模板插值和vue的指令等等\",\"因为vue的模板编译功能，vue会把用户写在template中的类似于html的内容解析编译，把原生的Html内容找出来，再把非原生的html找出来经过一系列的处理生成渲染函数,而render函数会将模板内容生成对应的VNode,而VNode再经过patch过程从而得到将要渲染的视图中的VNode，最后根据VNode创建真实的DOM节点并插入到视图中，最终完成视图的渲染更新\"]},\"144\":{\"h\":\"AST抽象语法树\",\"t\":[\"定义自行百度 template中的内容对vue来说就是一堆字符串\"]},\"145\":{\"h\":\"字符串到render函数的流程\",\"t\":[\"模板解析-将字符串用正则等方式解析成AST\",\"优化-遍历AST找出其中的静态节点并打上标记\",\"代码生成-将AST转换成渲染函数\"]},\"146\":{\"h\":\"模板解析\",\"t\":[\"HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。\",\"模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数parse中先调用HTML解析器parseHTML 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。\"]},\"147\":{\"h\":\"HTML解析器\",\"t\":[\"第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析HTML模板时的一些参数，同时还定义了4个钩子函数。\",\"start -当解析到开始标签时调用 end -当解析到结束标签时调用 chars -当解析到文本时调用 comment -当解析到注释时调用\",\"模板编译阶段主线函数parse会将HTML模板字符串转化成AST，而parseHTML是用来解析模板字符串的，把模板字符串中不同的内容提取出来之后，那么谁来把提取出来的内容生成对应的AST呢？答案就是这4个钩子函数。\",\"start函数接收三个参数，分别是标签名tag、标签属性attrs、标签是否自闭合unary。当调用该钩子函数时，内部会调用createASTElement函数来创建元素类型的AST节点\",\"当解析到标签的文本时，触发chars钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本。如果是动态文本，则创建动态文本类型的AST节点；如果不是动态文本，则创建纯静态文本类型的AST节点。\",\"当解析到标签的注释时，触发comment钩子函数，该钩子函数会创建一个注释类型的AST节点\",\"一边解析不同的内容一边调用对应的钩子函数生成对应的AST节点，最终完成将整个模板字符串转化成AST,这就是HTML解析器所要做的工作。\",\"如何解析不同的内容？\",\"模板字符串通常包含 文本，html注释，条件注释,DOCTYPE，开始标签，结束标签\",\"条件注释：\",\"<!-- [if !IE]> -->我是注释<!--< ![endif] --> \",\"这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理\",\"解析HTML注释 HTML注释是以结尾，这两者中间的内容就是注释内容 如果模板字符串html符合注释开始的正则，那么就继续向后查找是否存在-->，若存在，则把html从第4位（\\\"处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的comment函数，将真实的注释内容传进去，创建注释类型的AST节点。\",\"注意： 平常在模板中可以在标签上配置comments选项来决定在渲染模板时是否保留注释，对应到代码中就是options.shouldKeepComment,如果用户配置了comments选项为true，则shouldKeepComment为true，则创建注释类型的AST节点，如不保留注释，则将游标移动到'-->'之后，继续向后解析。\",\"advance函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析\",\"解析条件注释 先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的DOM树中，所以不需要调用钩子函数创建AST节点。\",\"解析DOCTYPE 原理同解析条件注释完全相同\",\"解析开始标签 首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征 当解析开始标签时，会调用4个钩子函数中的start函数,start函数需要传递三个参数:标签名，标签属性，是否自闭合。 标签名可以通过正则匹配的结果直接拿到，但是剩下两个就需要进一步处理\",\"解析结束标签\"]},\"148\":{\"h\":\"优化\"},\"149\":{\"h\":\"代码生成\"},\"150\":{\"h\":\"虚拟DOM?\",\"t\":[\"用一个对象来描述一个DOM节点\",\"因为浏览器的标准就把DOM设计的非常复杂，且Vue的特点是数据驱动视图。那么就意味着只要数据发生变化，就要操作DOM,由此可见，直接操作真实DOM是非常消耗性能的\",\"用js的计算性能来换取操作DOM所消耗的性能 我们不要盲目的去更新视图， 通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作DOM了。这也就是上面所说的用JS的计算性能来换取操作DOM的性能。 用JS模拟出一个DOM节点，称之为虚拟DOM节点。当数据发生变化时，我们对比变化前后的虚拟DOM节点，通过DOM-Diff算法计算出需要更新的地方，然后去更新需要更新的视图。\",\"Vue中 存在一个VNode类通过这个类，可以实例出不同类型的虚拟DOM节点 VNode中包含了描述一个真实DOM节点所需要的一系列属性，通过属性之间不同的搭配就可以描述出各种类型的真实DOM节点\"]},\"151\":{\"h\":\"VNode的类型\",\"t\":[\"通过实例化时传入的属性参数不同主要可以搭配为以下的几种类型的节点\",\"注释节点\",\"文本节点\",\"元素节点\",\"组件节点\",\"函数式组件节点\",\"克隆节点\",\"只需两个属性：text注释的内容， isComment用来标志一个节点是否为注释节点\",\"只需一个属性，text文本内容\",\"更加能够描述一个节点，包括tag,data,children用来指定该节点的标签名，class,id等data属性，孩子节点\",\"除了具备元素节点的属性外，还有componentOptions,componentInstance分别用来表示组件的option选项(如props),当前组件节点对应的Vue实例\",\"除了组件节点的属性外，还有fnContext,fnOptions分别用来表示函数式组件对应的Vue实例，组件的option选项\",\"将已有的节点的属性全部复制到新节点中，新旧节点唯一的区别是新节点的isCloned为true\"]},\"152\":{\"h\":\"VNode的作用\",\"t\":[\"在视图渲染之前，把写好的template模板先编译成VNode缓存下来，等到数据发送变化页面需要重新渲染的时候，我们把数据发生变化后生成的真实VNode与前一次缓存的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入视图中，最终完成一次视图更新\"]},\"153\":{\"h\":\"DOM-Diff\",\"t\":[\"DOM-Diff过程叫做patch过程 以新的VNode为标准， 如果新的有的而旧的没有那么在旧的VNode上添加 如果新的没有的而旧的有那么就把旧的VNode上有的移除 如果某些节点在新的VNode和旧的VNode上都有，那么以新的为准更新旧的VNode,从而让新旧VNode相同\",\"总之：就是对旧的节点进行创建节点，删除节点，更新节点\"]},\"154\":{\"h\":\"创建节点：\",\"t\":[\"VNode描述的节点有6种类型，但是可以直接创建并插入到DOM中的只有元素节点，文本节点，注释节点，所以Vue在创建节点的时候会先判断在新的VNode中有而旧的VNode中没有的节点属于那种类型，从而调用不同的方法创建并插入到DOM中\",\"判断是否为元素节点只需判断该VNode节点是否有tag标签即可，如果有tag属性即认为是元素节点，调用createElement方法创建元素节点，如果有子节点那么就会递归遍历创建所有子节点，将所有子节点创建好之后insert插入到当前元素节点里面，最后把当前节点插入到DOM中\",\"判断是否为注释节点，只需要看isComment是否为true，若是则调用createComment方法创建注释节点，再插入到DOM中\",\"其中nodeOps是Vue跨平台兼容性，对所有节点操作进行了封装，例如nodeOps.createTextNode()在浏览器端等同于document.createTextNode()\",\"如果既不是元素节点，也不是注释节点，那就是文本节点，调用createTextNode方法创建文本节点，再插入到DOM中\"]},\"155\":{\"h\":\"删除节点\",\"t\":[\"在删除节点的父元素上调用removeChild方法即可\"]},\"156\":{\"h\":\"更新节点\",\"t\":[\"静态节点\",\"// 不管数据怎么变化都与该节点无关 <p>静态节点</p> \",\"需要考虑3种情况分别进行处理\",\"如果新的VNode和旧的VNode均为静态节点 直接跳过，不用处理\",\"如果新的VNode是文本节点 如果新的VNode是文本节点表示这个节点的内容是纯文本，那么只需看旧的VNode中是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把旧的VNode里的文本改为和新的文本一样。如果旧的VNode不是文本节点，那么不管它是什么，直接调用setTextNode方法将它改为文本节点且内容需要和新的VNode内容一致\",\"如果新的VNode是元素节点 又分两种情况 该节点包含子节点 那么此时要看旧的VNode中是否包含子节点，如果旧的VNode里也包含了子节点那就需要递归对比更新子节点。 如果旧的VNode不包含子节点，那么这个旧的VNode有可能是空节点或文本节点。 如果为空节点，那么就把新的VNode里的子节点创建一份然后插入到旧的VNode里。 如果旧的VNode中是文本节点，那么就抹除该文本节点，然后把新的VNode里的子节点创建一份然后插入到旧的VNode里 该节点不包含子节点 那就说明它是一个空节点，那么直接清空旧的VNode\",\"注意：如果新旧的VNode里都包含子节点，那么对应子节点的更新在代码里调用了updateChildren方法\"]},\"157\":{\"h\":\"更新子节点\",\"t\":[\"当新的VNode与旧的VNode都是元素节点并且都包含子节点时，那么这两个节点的VNode实例上的children属性就是所包含的子节点数组，需要把新的子节点数组里面的元素与旧的子节点数组里面的元素进行一一比对，那么就会出现以下四种情况\",\"创建子节点 如果新的子节点数组里面的某个子节点在旧的子节点数组里面找不到与之对应的子节点，那么说明新的子节点数组里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点 新创建的节点插入到所有未处理节点之前，而不是插入到所有已处理节点之后\",\"删除子节点 如果把新的子节点数组里面的每个子节点都循环完毕后，发现旧的子节点数组中还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除\",\"移动子节点 如果新的子节点里面的某个子节点在旧的子节点数组中找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以新的子节点数组里子节点的位置为基准，调整旧的子节点数组里该节点的位置，使之与新的子节点数组里的位置相同。 将旧的子节点调整到所有未处理节点之前且顺序要与新的子节点位置一致\",\"更新节点 如果新的子节点数组里面的某个子节点在旧的子节点数组里面找到了与之相同的子节点，并所处的位置也相同，那么就更新旧的子节点数组里该节点，使之与新的子节点数组里的该节点相同。\"]},\"158\":{\"h\":\"优化更新子节点\",\"t\":[\"上面所用到的更新操作的时间复杂度为n^2存在效率问题\"]},\"159\":{\"h\":\"优化策略\",\"t\":[\"不再顺序去循环新旧子节点数组，而是对比新旧子节点中特殊的位置的子节点，如：\\n新子节点数组中所有未处理子节点的第一个节点和旧的子节点数组中所有未处理子节点的第一个子节点对比，\\n如果相同直接进行更新节点的操作，\\n如果不同再把新的子节点数组中所有未处理子节点的最后一个子节点与旧的子节点数组中所有未处理子节点的最后一个子节点对比，\\n如果相同那就直接进行更新节点的操作，\\n如果不同再把新的子节点数组中所有未处理子节点的最后一个子节点与旧的子节点数组中所有未处理子节点的第一个子节点进行对比，\\n如果相同，就直接进行更新节点的操作，更新完之后再将旧的子节点数组中该节点移动到与新的子节点数组里节点相同的位置，\\n如果不同，再把新的子节点数组中所有未处理的子节点的第一个子节点和旧的子节点数组中的所有未处理子节点的最后一个子节点对比，\\n如果相同那就直接进入更新节点的操作，更新完再将旧的子节点数组中的该节点移动到与新的子节点数组中节点相同的位置，\\n如果上面都不满足，再按照之前的循环方式来查找节点\\n这里的循环不再是之前的顺序循环进行查找，而是从两边向中间进行查找，新旧子节点两个数组分别有两个指针，第一个指针指向第一个元素的下标，第二个指针指向最后一个元素的下标\\n当指针所指向的节点被处理之后，指针才会向中间进行移动(新子节点数组第一个下标和就子节点数组第一个下标只会增加，新子节点数组最后一个下标和就子节点数组最后一个下标只会减少)\\n当开始位置大于结束位置时，表示所有节点都已经遍历过了\"]},\"160\":{\"h\":\"java基础\"},\"161\":{\"h\":\"css基础\"},\"162\":{\"h\":\"html基础\"},\"163\":{\"h\":\"js基础\"}},\"dirtCount\":0,\"index\":[[\"上面所用到的更新操作的时间复杂度为n^2存在效率问题\",{\"1\":{\"158\":1}}],[\"上一个事务还没有提交\",{\"1\":{\"10\":1}}],[\"使之与新的子节点数组里的该节点相同\",{\"1\":{\"157\":1}}],[\"使之与新的子节点数组里的位置相同\",{\"1\":{\"157\":1}}],[\"使用\",{\"1\":{\"124\":1}}],[\"使用基础vue构造器\",{\"1\":{\"124\":1}}],[\"使用explain命令分析执行的sql语句是否使用了索引\",{\"1\":{\"110\":1}}],[\"使用什么表达式作为建立索引的字段\",{\"1\":{\"109\":1}}],[\"使用索引时需要综合考虑索引的优点和缺点\",{\"1\":{\"103\":1}}],[\"使用key或index关键字定义\",{\"1\":{\"103\":1}}],[\"使用truncate删除数据后\",{\"1\":{\"101\":1}}],[\"使用truncate语句来删除数据表中所有的数据\",{\"0\":{\"101\":1}}],[\"使用update语句更新数据时\",{\"1\":{\"97\":1}}],[\"使用delete语句删除数据\",{\"1\":{\"101\":1}}],[\"使用delete语句可以删除数据表中的全部数据\",{\"1\":{\"100\":1}}],[\"使用delete语句可以删除部分数据\",{\"1\":{\"99\":1}}],[\"使用delete删除数据时\",{\"1\":{\"88\":1}}],[\"使用desc语句查看表结构时\",{\"1\":{\"83\":1}}],[\"使用desc语句查看数据表结构\",{\"0\":{\"68\":1}}],[\"使用auto\",{\"1\":{\"88\":1}}],[\"使用year类型时\",{\"1\":{\"62\":1}}],[\"使用show\",{\"1\":{\"60\":1}}],[\"使用start\",{\"1\":{\"10\":1}}],[\"使用root用户登录mysql\",{\"1\":{\"28\":1}}],[\"使用事务时的注意事项\",{\"1\":{\"10\":1}}],[\"移动子节点\",{\"1\":{\"157\":1}}],[\"发现旧的子节点数组中还有未处理的子节点\",{\"1\":{\"157\":1}}],[\"又分两种情况\",{\"1\":{\"156\":1}}],[\"静态节点\",{\"1\":{\"156\":1}}],[\"判断是否为注释节点\",{\"1\":{\"154\":1}}],[\"判断是否为元素节点只需判断该vnode节点是否有tag标签即可\",{\"1\":{\"154\":1}}],[\"判断传入的插件如果是一个提供了\",{\"1\":{\"124\":1}}],[\"判断传入的definition参数是否是一个对象\",{\"1\":{\"124\":1}}],[\"就直接进行更新节点的操作\",{\"1\":{\"159\":1}}],[\"就是对旧的节点进行创建节点\",{\"1\":{\"153\":1}}],[\"就要操作dom\",{\"1\":{\"150\":1}}],[\"就要满足一定的规范化要求\",{\"1\":{\"38\":1}}],[\"总之\",{\"1\":{\"153\":1}}],[\"总共有12个都是直接挂在vue上的方法叫做全局api分别为\",{\"1\":{\"124\":1}}],[\"找出差异\",{\"1\":{\"152\":1}}],[\"等到数据发送变化页面需要重新渲染的时候\",{\"1\":{\"152\":1}}],[\"孩子节点\",{\"1\":{\"151\":1}}],[\"更加能够描述一个节点\",{\"1\":{\"151\":1}}],[\"更新完再将旧的子节点数组中的该节点移动到与新的子节点数组中节点相同的位置\",{\"1\":{\"159\":1}}],[\"更新完之后再将旧的子节点数组中该节点移动到与新的子节点数组里节点相同的位置\",{\"1\":{\"159\":1}}],[\"更新子节点\",{\"0\":{\"157\":1}}],[\"更新节点\",{\"0\":{\"156\":1},\"1\":{\"153\":1,\"157\":1}}],[\"更新了\",{\"1\":{\"124\":2}}],[\"更新部分数据指通过where子句指定更新数据条件\",{\"1\":{\"96\":1}}],[\"更新数据\",{\"0\":{\"95\":1}}],[\"更新操作异常等情况\",{\"1\":{\"38\":1}}],[\"克隆节点\",{\"1\":{\"151\":1}}],[\"元素节点\",{\"1\":{\"151\":1}}],[\"存在一个vnode类通过这个类\",{\"1\":{\"150\":1}}],[\"称之为虚拟dom节点\",{\"1\":{\"150\":1}}],[\"计算出视图中哪些地方需要更新\",{\"1\":{\"150\":1}}],[\"计算机采用二进制方式保存数据\",{\"1\":{\"58\":1}}],[\"我们把数据发生变化后生成的真实vnode与前一次缓存的vnode进行对比\",{\"1\":{\"152\":1}}],[\"我们对比变化前后的虚拟dom节点\",{\"1\":{\"150\":1}}],[\"我们不要盲目的去更新视图\",{\"1\":{\"150\":1}}],[\"我们在日常业务开发中几乎用不到\",{\"1\":{\"124\":1}}],[\"我们在vue类上创建了options属性\",{\"1\":{\"124\":1}}],[\"由此可见\",{\"1\":{\"150\":1}}],[\"由于条件注释不存在于真正的dom树中\",{\"1\":{\"147\":1}}],[\"由于插件只会被安装一次\",{\"1\":{\"124\":1}}],[\"由于begin与存储过程中的begin\",{\"1\":{\"10\":1}}],[\"看模板字符串是否具有开始标签的特征\",{\"1\":{\"147\":1}}],[\"先用正则判断是否是以条件注释特有的开头标识开始\",{\"1\":{\"147\":1}}],[\"先用html解析器进行解析整个模板\",{\"1\":{\"146\":1}}],[\"确保不会重复解析\",{\"1\":{\"147\":1}}],[\"确保删除能触发更新视图\",{\"1\":{\"124\":1}}],[\"继续向后解析\",{\"1\":{\"147\":1}}],[\"平常在模板中可以在标签上配置comments选项来决定在渲染模板时是否保留注释\",{\"1\":{\"147\":1}}],[\"截取得到的内容就是注释的真实内容\",{\"1\":{\"147\":1}}],[\"处\",{\"1\":{\"147\":1}}],[\"解析结束标签\",{\"1\":{\"147\":1}}],[\"解析开始标签\",{\"1\":{\"147\":1}}],[\"解析doctype\",{\"1\":{\"147\":1}}],[\"解析条件注释\",{\"1\":{\"147\":1}}],[\"解析完一部分就把游标向后移动一部分\",{\"1\":{\"147\":1}}],[\"解析html注释\",{\"1\":{\"147\":1}}],[\"解决方案\",{\"0\":{\"142\":1}}],[\"结束标签\",{\"1\":{\"147\":1}}],[\"结果为19\",{\"1\":{\"96\":1}}],[\"结果表中有3+2个字段\",{\"1\":{\"42\":1}}],[\"开始标签\",{\"1\":{\"147\":1}}],[\"条件注释\",{\"1\":{\"147\":2}}],[\"条件表达式\",{\"1\":{\"96\":1,\"99\":1}}],[\"触发comment钩子函数\",{\"1\":{\"147\":1}}],[\"触发chars钩子函数\",{\"1\":{\"147\":1}}],[\"触发setter更新\",{\"1\":{\"134\":1}}],[\"答案就是这4个钩子函数\",{\"1\":{\"147\":1}}],[\"模板字符串通常包含\",{\"1\":{\"147\":1}}],[\"模板编译阶段主线函数parse会将html模板字符串转化成ast\",{\"1\":{\"147\":1}}],[\"模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来\",{\"1\":{\"146\":1}}],[\"模板解析\",{\"0\":{\"146\":1},\"1\":{\"1\":1,\"145\":1}}],[\"重点看第二个参数\",{\"1\":{\"147\":1}}],[\"无需多言\",{\"1\":{\"147\":1}}],[\"无论事务是否提交\",{\"1\":{\"10\":1}}],[\"函数式组件节点\",{\"1\":{\"151\":1}}],[\"函数对模板字符串进行解析\",{\"1\":{\"146\":1}}],[\"函数返回的对象\",{\"1\":{\"124\":1}}],[\"文本节点\",{\"1\":{\"151\":1,\"154\":1}}],[\"文本\",{\"1\":{\"147\":1}}],[\"文本解析器和过滤器解析器\",{\"1\":{\"146\":1}}],[\"文件类型等\",{\"0\":{\"35\":1}}],[\"代码生成\",{\"0\":{\"149\":1},\"1\":{\"145\":1}}],[\"遍历ast找出其中的静态节点并打上标记\",{\"1\":{\"145\":1}}],[\"遍历依赖\",{\"1\":{\"134\":1}}],[\"优化策略\",{\"0\":{\"159\":1}}],[\"优化更新子节点\",{\"0\":{\"158\":1}}],[\"优化\",{\"0\":{\"148\":1},\"1\":{\"145\":1}}],[\"优点\",{\"1\":{\"112\":1}}],[\"把写好的template模板先编译成vnode缓存下来\",{\"1\":{\"152\":1}}],[\"把模板字符串中不同的内容提取出来之后\",{\"1\":{\"147\":1}}],[\"把原生的html内容找出来\",{\"1\":{\"143\":1}}],[\"把使用频率最高的字段放在索引字段列表的最左边\",{\"1\":{\"103\":1}}],[\"有了模板编译才有vnode\",{\"1\":{\"143\":1}}],[\"有任意一个满足条件的即可\",{\"1\":{\"52\":1}}],[\"属性改为拦截器就挂载到实例和array\",{\"1\":{\"139\":1}}],[\"属性和联系的转换\",{\"0\":{\"34\":1}}],[\"目的为了触发getter收集在window\",{\"1\":{\"134\":1}}],[\"类\",{\"1\":{\"133\":1}}],[\"何为模板编译\",{\"0\":{\"143\":1}}],[\"何为依赖\",{\"0\":{\"133\":1}}],[\"何时通知依赖更新\",{\"0\":{\"131\":1,\"138\":1}}],[\"何时收集\",{\"0\":{\"130\":1,\"137\":1}}],[\"收集好的依赖放置在何处\",{\"0\":{\"132\":1}}],[\"收集起来好进行更新操作\",{\"1\":{\"129\":1}}],[\"依赖收集到哪里\",{\"0\":{\"140\":1}}],[\"依赖收集时一个数据有多个依赖者所以通过依赖管理器dep\",{\"1\":{\"132\":1}}],[\"依赖收集\",{\"0\":{\"129\":1}}],[\"避免重复操作\",{\"1\":{\"128\":1}}],[\"变化侦听\",{\"0\":{\"127\":1}}],[\"响应式\",{\"0\":{\"127\":1}}],[\"x\",{\"1\":{\"124\":4}}],[\"xx\",{\"1\":{\"122\":3}}],[\"让一个对象可响应\",{\"1\":{\"124\":1}}],[\"然后把新的vnode里的子节点创建一份然后插入到旧的vnode里\",{\"1\":{\"156\":1}}],[\"然后有差异的vnode对应的真实dom节点就是需要重新渲染的节点\",{\"1\":{\"152\":1}}],[\"然后去更新需要更新的视图\",{\"1\":{\"150\":1}}],[\"然后寻找其特有的结束标识\",{\"1\":{\"147\":1}}],[\"然后调用4个钩子函数中的comment函数\",{\"1\":{\"147\":1}}],[\"然后再把不同的内容做不同的处理\",{\"1\":{\"147\":1}}],[\"然后释放window\",{\"1\":{\"134\":1}}],[\"然后将其赋值给vue\",{\"1\":{\"124\":1}}],[\"然后将合并后的新对象作为this\",{\"1\":{\"124\":1}}],[\"然后给sub类添加一些属性以及将父类的某些属性复制到sub类上\",{\"1\":{\"124\":1}}],[\"影响之后所有创建的每个vue实例\",{\"1\":{\"124\":1}}],[\"9\",{\"1\":{\"124\":1}}],[\"传入的插件可以是一个提供了\",{\"1\":{\"124\":1}}],[\"传入一个选项对象\",{\"1\":{\"124\":1}}],[\"传入一个扩展过的构造器\",{\"1\":{\"124\":1}}],[\"防止重复安装\",{\"1\":{\"124\":2}}],[\"首先使用开始标签的正则去匹配模板字符串\",{\"1\":{\"147\":1}}],[\"首先会判断文本是不是一个带变量的动态文本\",{\"1\":{\"147\":1}}],[\"首先\",{\"1\":{\"124\":1}}],[\"首先判断传入的插件是否存在于installedplugins数组中\",{\"1\":{\"124\":1}}],[\"首先定义了一个变量installedplugins\",{\"1\":{\"124\":1}}],[\"下面我们就来看一下该api的内部实现原理\",{\"1\":{\"124\":2}}],[\"另外\",{\"1\":{\"124\":1}}],[\"之后\",{\"1\":{\"147\":1}}],[\"之后再数密码\",{\"1\":{\"25\":1}}],[\"之前被调用\",{\"1\":{\"124\":1}}],[\"方法并传入参数完成插件安装\",{\"1\":{\"124\":1}}],[\"方法的对象\",{\"1\":{\"124\":2}}],[\"方法被同一个插件多次调用\",{\"1\":{\"124\":2}}],[\"方法调用时\",{\"1\":{\"124\":1}}],[\"方法\",{\"1\":{\"124\":4}}],[\"方式二\",{\"1\":{\"121\":1}}],[\"方式一\",{\"1\":{\"121\":1}}],[\"插件作者可以使用混入\",{\"1\":{\"124\":1}}],[\"插件安装完成之后\",{\"1\":{\"124\":1}}],[\"插件将只会被安装一次\",{\"1\":{\"124\":1}}],[\"插件\",{\"1\":{\"124\":1}}],[\"java基础\",{\"0\":{\"160\":1}}],[\"js基础\",{\"0\":{\"163\":1}}],[\"json中的version字段\",{\"1\":{\"124\":1}}],[\"js的版本号\",{\"1\":{\"124\":1}}],[\"js插件的\",{\"1\":{\"124\":1}}],[\"js\",{\"1\":{\"124\":2}}],[\"js中\",{\"1\":{\"124\":1}}],[\"js和src\",{\"1\":{\"124\":1}}],[\"join相互替换时\",{\"1\":{\"49\":1}}],[\"join和right\",{\"1\":{\"49\":1}}],[\"join\",{\"1\":{\"42\":1,\"43\":1,\"44\":1,\"47\":1,\"48\":1}}],[\"位于源码的src\",{\"1\":{\"124\":1}}],[\"是需要此次新增的节点\",{\"1\":{\"157\":1}}],[\"是否自闭合\",{\"1\":{\"147\":1}}],[\"是的\",{\"1\":{\"124\":1}}],[\"是用来存放全局组件的地方\",{\"1\":{\"124\":1}}],[\"是用来存放全局过滤器的地方\",{\"1\":{\"124\":1}}],[\"细心的你肯定会发现这三个api的代码实现非常的相似\",{\"1\":{\"124\":1}}],[\"组件的option选项\",{\"1\":{\"151\":1}}],[\"组件节点\",{\"1\":{\"151\":1}}],[\"组件id和组件的定义\",{\"1\":{\"124\":1}}],[\"组织数据入库\",{\"0\":{\"36\":1}}],[\"始终返回构造器\",{\"1\":{\"124\":1}}],[\"那就以新的子节点数组里子节点的位置为基准\",{\"1\":{\"157\":1}}],[\"那就说明这些未处理的子节点是需要被废弃的\",{\"1\":{\"157\":1}}],[\"那就说明它是一个空节点\",{\"1\":{\"156\":1}}],[\"那就比较两个文本是否不同\",{\"1\":{\"156\":1}}],[\"那就是文本节点\",{\"1\":{\"154\":1}}],[\"那就调用文本解析器来解析文本\",{\"1\":{\"146\":1}}],[\"那就直接将其保存在this\",{\"1\":{\"124\":1}}],[\"那么说明新的子节点数组里面的这个子节点是之前没有的\",{\"1\":{\"157\":1}}],[\"那么对应子节点的更新在代码里调用了updatechildren方法\",{\"1\":{\"156\":1}}],[\"那么直接清空旧的vnode\",{\"1\":{\"156\":1}}],[\"那么此时要看旧的vnode中是否包含子节点\",{\"1\":{\"156\":1}}],[\"那么不管它是什么\",{\"1\":{\"156\":1}}],[\"那么只需看旧的vnode中是否也是文本节点\",{\"1\":{\"156\":1}}],[\"那么以新的为准更新旧的vnode\",{\"1\":{\"153\":1}}],[\"那么谁来把提取出来的内容生成对应的ast呢\",{\"1\":{\"147\":1}}],[\"那么这两个节点的vnode实例上的children属性就是所包含的子节点数组\",{\"1\":{\"157\":1}}],[\"那么这个旧的vnode有可能是空节点或文本节点\",{\"1\":{\"156\":1}}],[\"那么这个函数会被作为\",{\"1\":{\"124\":1}}],[\"那么这些方法称为数组的\",{\"1\":{\"138\":1}}],[\"那么数组中可改变数据的方法也是对数据进行了操作\",{\"1\":{\"138\":1}}],[\"那么就更新旧的子节点数组里该节点\",{\"1\":{\"157\":1}}],[\"那么就将这些节点删除\",{\"1\":{\"157\":1}}],[\"那么就创建子节点\",{\"1\":{\"157\":1}}],[\"那么就会出现以下四种情况\",{\"1\":{\"157\":1}}],[\"那么就抹除该文本节点\",{\"1\":{\"156\":1}}],[\"那么就把新的vnode里的子节点创建一份然后插入到旧的vnode里\",{\"1\":{\"156\":1}}],[\"那么就把这个函数当作install方法执行\",{\"1\":{\"124\":1}}],[\"那么就意味着只要数据发生变化\",{\"1\":{\"150\":1}}],[\"那么就继续向后查找是否存在\",{\"1\":{\"147\":1}}],[\"那么就执行该对象中提供的\",{\"1\":{\"124\":1}}],[\"那么就从存放组件的地方根据组件id来读取组件并返回\",{\"1\":{\"124\":1}}],[\"那么就从存放过滤器的地方根据过滤器id来读取过滤器并返回\",{\"1\":{\"124\":1}}],[\"那么在非生产环境下首先会校验组件的name值是否合法\",{\"1\":{\"124\":1}}],[\"那么即认为它是用户自定义的指令对象\",{\"1\":{\"124\":1}}],[\"那么继续判断definition参数是否是一个函数\",{\"1\":{\"124\":1}}],[\"那么从存放指令的地方根据指令id来读取指令并返回\",{\"1\":{\"124\":1}}],[\"那么名称为primary\",{\"1\":{\"109\":1}}],[\"那么值的顺序必须和数据表定义的字段顺序相同\",{\"1\":{\"93\":1}}],[\"那么结果就是唯一的\",{\"1\":{\"82\":1}}],[\"同时还定义了4个钩子函数\",{\"1\":{\"147\":1}}],[\"同时传入参数完成插件安装\",{\"1\":{\"124\":1}}],[\"同时将vue插入到该数组的第一个位置\",{\"1\":{\"124\":1}}],[\"同时将vue\",{\"1\":{\"124\":1}}],[\"同时如果definition对象中不存在name属性时\",{\"1\":{\"124\":1}}],[\"同全局指令一样\",{\"1\":{\"124\":4}}],[\"同一列中不能有多个值\",{\"1\":{\"38\":1}}],[\"获取一下被依赖的数据\",{\"1\":{\"134\":1}}],[\"获取组件是根据组件id从存放组件的位置来读取组件\",{\"1\":{\"124\":1}}],[\"获取注册的组件\",{\"1\":{\"124\":1}}],[\"获取过滤器是根据过滤器id从存放过滤器的位置来读取过滤器\",{\"1\":{\"124\":1}}],[\"获取指令是根据指令id从存放指令的位置来读取指令\",{\"1\":{\"124\":1}}],[\"获取更新后的dom\",{\"1\":{\"124\":1}}],[\"接下来获取到传入的其余参数\",{\"1\":{\"124\":1}}],[\"接着\",{\"1\":{\"124\":1}}],[\"接着通过原型继承的方式将该类继承基础vue类\",{\"1\":{\"124\":1}}],[\"接收两个参数\",{\"1\":{\"124\":2}}],[\"接受两个参数\",{\"1\":{\"124\":1}}],[\"从而调用不同的方法创建并插入到dom中\",{\"1\":{\"154\":1}}],[\"从而让新旧vnode相同\",{\"1\":{\"153\":1}}],[\"从而达到改变其原有特性的效果\",{\"1\":{\"124\":1}}],[\"从用法回顾中可以知道\",{\"1\":{\"124\":2}}],[\"从用法中可以知道\",{\"1\":{\"124\":1}}],[\"从获取日期和时间时\",{\"1\":{\"62\":1}}],[\"调用createtextnode方法创建文本节点\",{\"1\":{\"154\":1}}],[\"调用createelement方法创建元素节点\",{\"1\":{\"154\":1}}],[\"调用this\",{\"1\":{\"134\":1}}],[\"调用\",{\"1\":{\"124\":1}}],[\"调整旧的子节点数组里该节点的位置\",{\"1\":{\"157\":1}}],[\"调整\",{\"0\":{\"37\":1}}],[\"注释节点\",{\"1\":{\"151\":1,\"154\":1}}],[\"注册全局组件是将定义好的组件存放在某个位置\",{\"1\":{\"124\":1}}],[\"注册组件\",{\"1\":{\"124\":2}}],[\"注册还会自动使用给定的id设置组件的名称\",{\"1\":{\"124\":1}}],[\"注册过滤器是将定义好的过滤器存放在某个位置\",{\"1\":{\"124\":1}}],[\"注册或获取全局组件\",{\"1\":{\"124\":1}}],[\"注册或获取全局过滤器\",{\"1\":{\"124\":1}}],[\"注册或获取全局指令\",{\"1\":{\"124\":1}}],[\"注册指令是将定义好的指令存放在某个位置\",{\"1\":{\"124\":1}}],[\"注册\",{\"1\":{\"124\":3}}],[\"注意\",{\"1\":{\"124\":1,\"147\":1,\"156\":1}}],[\"比如\",{\"1\":{\"124\":1}}],[\"比如更新\",{\"1\":{\"2\":1}}],[\"因为浏览器的标准就把dom设计的非常复杂\",{\"1\":{\"150\":1}}],[\"因为vue的模板编译功能\",{\"1\":{\"143\":1}}],[\"因为vue无法探测普通的新增属性\",{\"1\":{\"124\":1}}],[\"因为template中除了有html标签还有模板插值和vue的指令等等\",{\"1\":{\"143\":1}}],[\"因为返回的是一个对象\",{\"1\":{\"137\":1}}],[\"因为上文中我们说了\",{\"1\":{\"124\":1}}],[\"因此\",{\"1\":{\"103\":1}}],[\"因此不推荐使用begin\",{\"1\":{\"10\":1}}],[\"向组件注入自定义行为\",{\"1\":{\"124\":1}}],[\"向响应式对象中添加一个属性\",{\"1\":{\"124\":1}}],[\"向数据表中插入新记录时\",{\"1\":{\"89\":1}}],[\"返回的对象可以直接用于渲染函数和计算属性内\",{\"1\":{\"124\":1}}],[\"返回已注册的过滤器\",{\"1\":{\"124\":1}}],[\"返回已注册的指令\",{\"1\":{\"124\":1}}],[\"返回处理后的值\",{\"1\":{\"124\":1}}],[\"返回值\",{\"1\":{\"124\":1}}],[\"返回结果为多行多列数据的子查询\",{\"1\":{\"54\":1}}],[\"返回结果为多行一列数据的子查询\",{\"1\":{\"52\":1}}],[\"返回结果为一行多列数据的子查询\",{\"1\":{\"53\":1}}],[\"返回结果为一行一列数据的子查询\",{\"1\":{\"51\":1}}],[\"绑定在调用它的实例上\",{\"1\":{\"124\":1}}],[\"中\",{\"1\":{\"124\":3}}],[\"中回调的\",{\"1\":{\"124\":1}}],[\"中使用\",{\"1\":{\"58\":1}}],[\"此处不再重复\",{\"1\":{\"124\":3}}],[\"此时执行start\",{\"1\":{\"10\":1}}],[\"$delete原理一样\",{\"1\":{\"124\":1}}],[\"$nexttick\",{\"1\":{\"124\":1}}],[\"$nexttick原理一样\",{\"1\":{\"124\":1}}],[\"$mount\",{\"1\":{\"124\":1}}],[\"你可以根据不同的版本号采取不同的策略\",{\"1\":{\"124\":1}}],[\"你得自己提供\",{\"1\":{\"124\":1}}],[\"你们都看我干嘛\",{\"1\":{\"124\":1}}],[\"所以vue在创建节点的时候会先判断在新的vnode中有而旧的vnode中没有的节点属于那种类型\",{\"1\":{\"154\":1}}],[\"所以不需要调用钩子函数创建ast节点\",{\"1\":{\"147\":1}}],[\"所以在解析器主线函数parse中先调用html解析器parsehtml\",{\"1\":{\"146\":1}}],[\"所以在接下来会根据这两种不同的情况分别处理\",{\"1\":{\"124\":1}}],[\"所以我们只需将传入的mixin对象与this\",{\"1\":{\"124\":1}}],[\"所以该api内部还应该防止\",{\"1\":{\"124\":1}}],[\"所以如果你的目标浏览器不原生支持\",{\"1\":{\"124\":1}}],[\"所有提交的数据可能都会丢失\",{\"1\":{\"6\":1}}],[\"的update方法从而更新页面\",{\"1\":{\"134\":1}}],[\"的\",{\"1\":{\"124\":1}}],[\"的环境中\",{\"1\":{\"124\":1}}],[\"请注意\",{\"1\":{\"124\":1}}],[\"详见接下来的提示\",{\"1\":{\"124\":1}}],[\"详情内容\",{\"1\":{\"39\":1}}],[\"详情\",{\"1\":{\"39\":1}}],[\"起新增\",{\"1\":{\"124\":2}}],[\"作为参数传入\",{\"1\":{\"124\":2}}],[\"作为一个\",{\"1\":{\"124\":1}}],[\"作用\",{\"1\":{\"124\":11}}],[\"还有fncontext\",{\"1\":{\"151\":1}}],[\"还有componentoptions\",{\"1\":{\"151\":1}}],[\"还是在getter中收集\",{\"1\":{\"137\":1}}],[\"还是根据是否传入了definition参数来决定本次操作是注册组件还是获取组件\",{\"1\":{\"124\":1}}],[\"还是根据是否传入了definition参数来决定本次操作是注册过滤器还是获取过滤器\",{\"1\":{\"124\":1}}],[\"还没有更新\",{\"1\":{\"124\":1}}],[\"还可以简化对数据的操作等等\",{\"1\":{\"112\":1}}],[\"还可以对基本表中的数据进行添加\",{\"1\":{\"112\":1}}],[\"源码分析\",{\"1\":{\"124\":1}}],[\"源码如下\",{\"1\":{\"124\":1}}],[\"源码\",{\"1\":{\"124\":2}}],[\"最终完成一次视图更新\",{\"1\":{\"152\":1}}],[\"最终完成将整个模板字符串转化成ast\",{\"1\":{\"147\":1}}],[\"最终完成对整个模板字符串的解析\",{\"1\":{\"146\":1}}],[\"最终完成视图的渲染更新\",{\"1\":{\"143\":1}}],[\"最后把当前节点插入到dom中\",{\"1\":{\"154\":1}}],[\"最后根据有差异的vnode创建出真实的dom节点再插入视图中\",{\"1\":{\"152\":1}}],[\"最后根据vnode创建真实的dom节点并插入到视图中\",{\"1\":{\"143\":1}}],[\"最后\",{\"1\":{\"124\":1}}],[\"最后将sub类返回\",{\"1\":{\"124\":1}}],[\"最左前缀\",{\"1\":{\"103\":1}}],[\">我是注释<\",{\"1\":{\"147\":1}}],[\">\",{\"1\":{\"124\":4,\"147\":4}}],[\"><\",{\"1\":{\"124\":1}}],[\"<p>静态节点<\",{\"1\":{\"156\":1}}],[\"<p>walter\",{\"1\":{\"124\":1}}],[\"<p>\",{\"1\":{\"124\":1}}],[\"<\",{\"1\":{\"124\":4,\"147\":2}}],[\"<div><span>\",{\"1\":{\"124\":1}}],[\"<div\",{\"1\":{\"124\":1}}],[\"示例\",{\"1\":{\"124\":2}}],[\"参数是一个包含组件选项的对象\",{\"1\":{\"124\":1}}],[\"参数\",{\"1\":{\"124\":10}}],[\"状态\",{\"1\":{\"117\":1}}],[\"这里的循环不再是之前的顺序循环进行查找\",{\"1\":{\"159\":1}}],[\"这里将会被\",{\"1\":{\"124\":1}}],[\"这说明此次变化需要调整该子节点的位置\",{\"1\":{\"157\":1}}],[\"这也就是上面所说的用js的计算性能来换取操作dom的性能\",{\"1\":{\"150\":1}}],[\"这样我们就可以尽可能少的操作dom了\",{\"1\":{\"150\":1}}],[\"这样当数据变化时\",{\"1\":{\"134\":1}}],[\"这两者中间的内容就是注释内容\",{\"1\":{\"147\":1}}],[\"这两种功能的切换取决于是否传入了definition参数\",{\"1\":{\"124\":1}}],[\"这几种内容都有其各自独有的特点\",{\"1\":{\"147\":1}}],[\"这就是html解析器所要做的工作\",{\"1\":{\"147\":1}}],[\"这对社区的插件和组件来说非常有用\",{\"1\":{\"124\":1}}],[\"这是因为在后续调用install方法时\",{\"1\":{\"124\":1}}],[\"这是我们为了便于理解故意拆开的\",{\"1\":{\"124\":1}}],[\"这个api虽然在日常的业务开发中几乎用不到\",{\"1\":{\"124\":1}}],[\"这个directives属性就是用来存放指令的位置\",{\"1\":{\"124\":1}}],[\"这个方法主要用于避开vue不能检测到属性被删除的限制\",{\"1\":{\"124\":1}}],[\"这种视图被称为基于多表的视图\",{\"1\":{\"116\":1}}],[\"这些数据表被称为基本表\",{\"1\":{\"112\":1}}],[\"操作数据时只需要满足该视图本身定义的条件\",{\"1\":{\"114\":1}}],[\"操作数据时满足所有有关视图和表定义的条件\",{\"1\":{\"114\":1}}],[\"操作系统的特性\",{\"0\":{\"35\":1}}],[\"它内部是调用了observe方法\",{\"1\":{\"124\":1}}],[\"它内部是调用了compiletofunctions方法\",{\"1\":{\"124\":1}}],[\"它会被作为\",{\"1\":{\"124\":1}}],[\"它必须用于向响应式对象上添加新属性\",{\"1\":{\"124\":1}}],[\"它的取值有cascaded\",{\"1\":{\"114\":1}}],[\"它可以是普通索引\",{\"1\":{\"103\":1}}],[\"若是则调用createcomment方法创建注释节点\",{\"1\":{\"154\":1}}],[\"若找到\",{\"1\":{\"147\":1}}],[\"若存在\",{\"1\":{\"147\":1}}],[\"若省略\",{\"1\":{\"114\":1}}],[\"若不存在则创建视图\",{\"1\":{\"114\":1}}],[\"若不指定字段添加位置\",{\"1\":{\"75\":1}}],[\"若数据库中已存在这个名称的视图就替换原有视图\",{\"1\":{\"114\":1}}],[\"=>\",{\"1\":{\"124\":3}}],[\"===\",{\"1\":{\"124\":18}}],[\"==\",{\"1\":{\"124\":4}}],[\"=\",{\"1\":{\"114\":2,\"124\":66}}],[\"=|<>|in|not\",{\"1\":{\"53\":1}}],[\"=|<>|>|>=|<|<=\",{\"1\":{\"51\":1}}],[\"基于两张或者两张以上的数据表创建视图\",{\"1\":{\"116\":1}}],[\"基于多表的视图\",{\"0\":{\"115\":1}}],[\"基于单表的视图\",{\"0\":{\"113\":1}}],[\"基本表中的数据也会发生变化\",{\"1\":{\"112\":1}}],[\"定义自行百度\",{\"1\":{\"144\":1}}],[\"定义\",{\"1\":{\"112\":1}}],[\"定点数\",{\"1\":{\"62\":1}}],[\"视图名2\",{\"1\":{\"123\":1}}],[\"视图名1\",{\"1\":{\"123\":1}}],[\"视图名\",{\"1\":{\"114\":2,\"118\":2,\"119\":1,\"120\":1,\"121\":2,\"122\":1}}],[\"视图中查询出来的数据也会随之改变\",{\"1\":{\"112\":1}}],[\"视图的数据来源于数据库中的数据表\",{\"1\":{\"112\":1}}],[\"视图是一种虚拟存在的表\",{\"1\":{\"112\":1}}],[\"视图\",{\"0\":{\"112\":1}}],[\"包括tag\",{\"1\":{\"151\":1}}],[\"包括\",{\"1\":{\"111\":1}}],[\"包括了存储过程\",{\"1\":{\"61\":1}}],[\"```\",{\"1\":{\"124\":1}}],[\"```js\",{\"1\":{\"124\":2}}],[\"`update`\",{\"1\":{\"124\":1}}],[\"`bind`\",{\"1\":{\"124\":1}}],[\"`primary`\",{\"1\":{\"111\":2}}],[\"`\",{\"1\":{\"111\":1}}],[\"`select`\",{\"1\":{\"58\":1}}],[\"分别是标签名tag\",{\"1\":{\"147\":1}}],[\"分别是列级约束和表级约束\",{\"1\":{\"82\":1}}],[\"分析sql是否使用索引\",{\"0\":{\"110\":1}}],[\"前言\",{\"0\":{\"124\":1}}],[\"前缀索引的长度\",{\"1\":{\"109\":1}}],[\"前者代表2000年\",{\"1\":{\"62\":1}}],[\"建立索引的字段\",{\"1\":{\"109\":1}}],[\"建立索引的字段序号值\",{\"1\":{\"109\":1}}],[\"建表语句\",{\"0\":{\"64\":1}}],[\"再按照之前的循环方式来查找节点\",{\"1\":{\"159\":1}}],[\"再把新的子节点数组中所有未处理的子节点的第一个子节点和旧的子节点数组中的所有未处理子节点的最后一个子节点对比\",{\"1\":{\"159\":1}}],[\"再把非原生的html找出来经过一系列的处理生成渲染函数\",{\"1\":{\"143\":1}}],[\"再插入到dom中\",{\"1\":{\"154\":2}}],[\"再创建数据表的同时创建索引\",{\"0\":{\"106\":1}}],[\"再次添加数据时\",{\"1\":{\"101\":1}}],[\"但是所处的位置不同\",{\"1\":{\"157\":1}}],[\"但是可以直接创建并插入到dom中的只有元素节点\",{\"1\":{\"154\":1}}],[\"但是剩下两个就需要进一步处理\",{\"1\":{\"147\":1}}],[\"但是对于插件编写非常有用\",{\"1\":{\"124\":1}}],[\"但是在编写vue插件时用处非常大\",{\"1\":{\"124\":1}}],[\"但是你应该很少会使用它\",{\"1\":{\"124\":1}}],[\"但同时索引会占用一定的磁盘空间\",{\"1\":{\"103\":1}}],[\"但逻辑上分为两张数据表\",{\"1\":{\"44\":1}}],[\"虽然索引可以提高数据的查询速度\",{\"1\":{\"103\":1}}],[\"原理同解析条件注释完全相同\",{\"1\":{\"147\":1}}],[\"原理分析\",{\"1\":{\"124\":10}}],[\"原数组的操作没有变化只是添加了一些功能\",{\"1\":{\"139\":1}}],[\"原因\",{\"1\":{\"137\":1}}],[\"原则\",{\"1\":{\"103\":1}}],[\"原子性指一个事务必须被视为一个不可分割的最小工作单元\",{\"1\":{\"3\":1}}],[\"原子性\",{\"1\":{\"2\":1}}],[\"复合索引默认使用第一个字段的名称表示\",{\"1\":{\"106\":1}}],[\"复合索引是指在多个字段上创建索引\",{\"1\":{\"103\":1}}],[\"复合索引\",{\"1\":{\"103\":1}}],[\"必须提供\",{\"1\":{\"124\":1}}],[\"必须将其声明为not\",{\"1\":{\"103\":1}}],[\"必须指定字段\",{\"1\":{\"93\":1}}],[\"形状以及自身分布特征的数据\",{\"1\":{\"103\":1}}],[\"形成一个概念数据模型\",{\"0\":{\"33\":1}}],[\"形成需求分析报告\",{\"0\":{\"32\":1}}],[\"大小\",{\"1\":{\"103\":1}}],[\"空间数据类型存储的空间数据是指含有位置\",{\"1\":{\"103\":1}}],[\"空间索引只能创建在空间数据类型的字段上\",{\"1\":{\"103\":1}}],[\"空间\",{\"1\":{\"103\":1}}],[\"唯一不同的是实例方法\",{\"1\":{\"124\":1}}],[\"唯一索引或者全文索引\",{\"1\":{\"103\":1}}],[\"唯一性索引会被自动创建\",{\"1\":{\"103\":1}}],[\"唯一性索引用于限制字段不能出现重复值时\",{\"1\":{\"103\":1}}],[\"唯一性\",{\"1\":{\"103\":1}}],[\"唯一约束可以在创建数据表时设置\",{\"1\":{\"81\":1}}],[\"唯一约束通过unique关键字设置\",{\"1\":{\"81\":1}}],[\"唯一约束用于确保字段中值的唯一性\",{\"1\":{\"81\":1}}],[\"唯一约束\",{\"0\":{\"81\":1}}],[\"普通索引是mysql中的基本索引类型\",{\"1\":{\"103\":1}}],[\"普通\",{\"1\":{\"103\":1}}],[\"常见的索引\",{\"1\":{\"103\":1}}],[\"常用的字符编码是\",{\"1\":{\"58\":1}}],[\"常用配置\",{\"0\":{\"20\":1}}],[\"物理的存储结构\",{\"1\":{\"102\":1}}],[\"物理结构设计\",{\"1\":{\"31\":1}}],[\"索引对查询优化器是否可见\",{\"1\":{\"109\":1}}],[\"索引字段的注释信息\",{\"1\":{\"109\":1}}],[\"索引字段是否含有null值\",{\"1\":{\"109\":1}}],[\"索引字段是否有排序\",{\"1\":{\"109\":1}}],[\"索引方式\",{\"1\":{\"109\":1}}],[\"索引的名称\",{\"1\":{\"109\":1}}],[\"索引的使用\",{\"0\":{\"104\":1}}],[\"索引是否可以重复\",{\"1\":{\"109\":1}}],[\"索引是一种单独的\",{\"1\":{\"102\":1}}],[\"索引所在的数据表的名称\",{\"1\":{\"109\":1}}],[\"索引类型\",{\"1\":{\"106\":4,\"107\":1,\"108\":3}}],[\"索引名\",{\"1\":{\"106\":4,\"107\":1,\"108\":3,\"111\":2}}],[\"索引\",{\"0\":{\"102\":1}}],[\"满足条件的数据会被删除\",{\"1\":{\"99\":1}}],[\"全局注册一个混入\",{\"1\":{\"124\":1}}],[\"全局api\",{\"1\":{\"1\":1}}],[\"全文索引只能创建在char\",{\"1\":{\"103\":1}}],[\"全文索引主要用于提高数据量较大的字段的查询效率\",{\"1\":{\"103\":1}}],[\"全文\",{\"1\":{\"103\":1}}],[\"全部\",{\"0\":{\"97\":1,\"100\":1}}],[\"运算符\",{\"1\":{\"96\":1}}],[\"乘\",{\"1\":{\"96\":1}}],[\"减\",{\"1\":{\"96\":1}}],[\"+state\",{\"1\":{\"124\":1}}],[\"+\",{\"1\":{\"96\":1,\"124\":3}}],[\"根据解析内容的不同分为html解析器\",{\"1\":{\"146\":1}}],[\"根据创建索引的字段个数分类\",{\"1\":{\"103\":1}}],[\"根据条件更新数据表中的一条或者多条数据\",{\"1\":{\"96\":1}}],[\"根据指定条件匹配数据库\",{\"1\":{\"60\":1}}],[\"根据指定的匹配模式匹配数据库\",{\"1\":{\"60\":1}}],[\"部分\",{\"0\":{\"96\":1,\"99\":1}}],[\"省略后效果相同\",{\"1\":{\"93\":1}}],[\"省略使用字符集对应的默认校对集\",{\"1\":{\"59\":1}}],[\"值越大可能性越高\",{\"1\":{\"109\":1}}],[\"值为相应字段名被修改后的值\",{\"1\":{\"97\":1}}],[\"值是字段被更新后的值\",{\"1\":{\"96\":1}}],[\"值表示字段对应的数据\",{\"1\":{\"93\":1}}],[\"值2\",{\"1\":{\"93\":2}}],[\"值1\",{\"1\":{\"93\":2}}],[\"单列索引默认使用建立索引的字段表示\",{\"1\":{\"106\":1}}],[\"单列索引是在表中单个字段上创建索引\",{\"1\":{\"103\":1}}],[\"单列索引\",{\"1\":{\"103\":1}}],[\"单条\",{\"0\":{\"93\":1}}],[\"单行长度限制是指一条记录中除blob系列和text系列外的其他常见数据类型的字段加起来不能超过限制\",{\"1\":{\"62\":1}}],[\"单行注释\",{\"1\":{\"58\":2}}],[\"且vue的特点是数据驱动视图\",{\"1\":{\"150\":1}}],[\"且触发视图更新\",{\"1\":{\"124\":1}}],[\"且null值不会被视为重复值\",{\"1\":{\"103\":1}}],[\"且该字段必须设置了唯一约束或主键约束\",{\"1\":{\"88\":1}}],[\"且必须满足d<=m\",{\"1\":{\"62\":1}}],[\"约束\",{\"1\":{\"87\":1}}],[\"每个数据表中只能设置一个主键约束\",{\"1\":{\"85\":1}}],[\"每一条sql语句不再自动提交\",{\"1\":{\"8\":1}}],[\"被约束字段不能出现重复值\",{\"1\":{\"85\":1}}],[\"主机地址\",{\"1\":{\"114\":1}}],[\"主键索引的索引名应使用primary\",{\"1\":{\"111\":1}}],[\"主键索引的字段不允许有null值\",{\"1\":{\"103\":1}}],[\"主键索引会被自动创建\",{\"1\":{\"103\":1}}],[\"主键索引用于根据主键自身的唯一性标识每一条记录\",{\"1\":{\"103\":1}}],[\"主键\",{\"1\":{\"103\":1}}],[\"主键约束可以在创建数据表时设置\",{\"1\":{\"85\":1}}],[\"主键约束通过primary\",{\"1\":{\"85\":1}}],[\"主键约束相当于非空约束和唯一约束的组合\",{\"1\":{\"85\":1}}],[\"主键约束用于将一个或多个字段设置为表的主键\",{\"1\":{\"85\":1}}],[\"主键约束\",{\"0\":{\"85\":1}}],[\"主要存储mysql自身需要使用的控制和管理信息\",{\"1\":{\"61\":1}}],[\"主要存储数据库和数据表的结构信息\",{\"1\":{\"61\":1}}],[\"给字段设置唯一约束后\",{\"1\":{\"83\":1}}],[\"其实在源码中这三个api的实现是写在一起的\",{\"1\":{\"124\":1}}],[\"其值也是一个空对象\",{\"1\":{\"124\":1}}],[\"其属性值为一个空对象\",{\"1\":{\"124\":1}}],[\"其消耗的时间是随着数据量的增加而增加的\",{\"1\":{\"103\":1}}],[\"其中nodeops是vue跨平台兼容性\",{\"1\":{\"154\":1}}],[\"其中\",{\"1\":{\"97\":1}}],[\"其效果与列级约束相同\",{\"1\":{\"82\":1}}],[\"其对数据库中数据的修改就是永久性的\",{\"1\":{\"6\":1}}],[\"紧跟在字段的数据类型之后\",{\"1\":{\"82\":1}}],[\"列级主键约束只能对单字段设置\",{\"1\":{\"85\":1}}],[\"列级\",{\"1\":{\"82\":1,\"85\":1}}],[\"列级约束定义在列中\",{\"1\":{\"82\":1}}],[\"列级约束和表级约束的区别\",{\"1\":{\"82\":1}}],[\"列子查询常用的运算符\",{\"1\":{\"52\":1}}],[\"列子查询\",{\"0\":{\"52\":1}}],[\"也不是注释节点\",{\"1\":{\"154\":1}}],[\"也不能出现null值\",{\"1\":{\"85\":1}}],[\"也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来\",{\"1\":{\"147\":1}}],[\"也可以说模板编译就是把用户写的模板经过一系列处理最终生成render函数的过程\",{\"1\":{\"143\":1}}],[\"也可以作为最小化的跨组件状态存储器\",{\"1\":{\"124\":1}}],[\"也可以是一个函数\",{\"1\":{\"124\":1}}],[\"也可以使用show\",{\"1\":{\"109\":1}}],[\"也可以对数据表中一列或多列的值进行排序\",{\"1\":{\"102\":1}}],[\"也可以在修改数据表时设置\",{\"1\":{\"80\":1,\"81\":1,\"85\":1,\"89\":1}}],[\"也必须设置\",{\"1\":{\"73\":1}}],[\"语法\",{\"1\":{\"124\":12}}],[\"语法是using\",{\"1\":{\"106\":1}}],[\"语法3\",{\"1\":{\"83\":1,\"85\":1}}],[\"语法2\",{\"1\":{\"76\":2,\"80\":2,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"90\":1,\"111\":1}}],[\"语法1\",{\"1\":{\"76\":2,\"80\":2,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"90\":1,\"111\":1}}],[\"添加数据时\",{\"1\":{\"93\":1}}],[\"添加数据\",{\"0\":{\"92\":1}}],[\"添加多个字段\",{\"1\":{\"75\":1}}],[\"添加一个字段\",{\"1\":{\"75\":1}}],[\"旧字段名\",{\"1\":{\"73\":3}}],[\"旧表名2\",{\"1\":{\"72\":1}}],[\"旧表名1\",{\"1\":{\"72\":1}}],[\"旧表名\",{\"1\":{\"72\":1}}],[\"新子节点数组最后一个下标和就子节点数组最后一个下标只会减少\",{\"1\":{\"159\":1}}],[\"新子节点数组第一个下标和就子节点数组第一个下标只会增加\",{\"1\":{\"159\":1}}],[\"新子节点数组中所有未处理子节点的第一个节点和旧的子节点数组中所有未处理子节点的第一个子节点对比\",{\"1\":{\"159\":1}}],[\"新旧子节点两个数组分别有两个指针\",{\"1\":{\"159\":1}}],[\"新旧节点唯一的区别是新节点的iscloned为true\",{\"1\":{\"151\":1}}],[\"新创建的节点插入到所有未处理节点之前\",{\"1\":{\"157\":1}}],[\"新增\",{\"1\":{\"132\":1}}],[\"新字段默认添加到数据表的最后\",{\"1\":{\"75\":1}}],[\"新字段名2\",{\"1\":{\"75\":1}}],[\"新字段名1\",{\"1\":{\"75\":1}}],[\"新字段名\",{\"1\":{\"73\":3,\"75\":1}}],[\"新数据类型\",{\"1\":{\"74\":2}}],[\"新表名2\",{\"1\":{\"72\":1}}],[\"新表名1\",{\"1\":{\"72\":1}}],[\"新表名\",{\"1\":{\"72\":1}}],[\"新密码\",{\"1\":{\"28\":1}}],[\"key关键字设置\",{\"1\":{\"85\":1}}],[\"key\",{\"1\":{\"68\":1,\"85\":5,\"86\":1,\"106\":1,\"108\":1,\"109\":1}}],[\"该节点不包含子节点\",{\"1\":{\"156\":1}}],[\"该节点包含子节点\",{\"1\":{\"156\":1}}],[\"该钩子函数会创建一个注释类型的ast节点\",{\"1\":{\"147\":1}}],[\"该变量初始值是一个空数组\",{\"1\":{\"124\":1}}],[\"该方法需要在调用\",{\"1\":{\"124\":1}}],[\"该api是在构建时读取了package\",{\"1\":{\"124\":1}}],[\"该api是用来标识当前构建的vue\",{\"1\":{\"124\":1}}],[\"该api是用来将一个普通对象转化成响应式对象\",{\"1\":{\"124\":1}}],[\"该api是用来编译模板字符串的\",{\"1\":{\"124\":1}}],[\"该api是用来向全局注册一个混入\",{\"1\":{\"124\":1}}],[\"该api是用来安装vue\",{\"1\":{\"124\":1}}],[\"该api是用来注册或获取全局组件的\",{\"1\":{\"124\":1}}],[\"该api是用来注册或获取全局过滤器的\",{\"1\":{\"124\":1}}],[\"该api是用来注册或获取全局指令的\",{\"1\":{\"124\":1}}],[\"该api就是通过修改vue\",{\"1\":{\"124\":1}}],[\"该api内部会调用插件提供的install\",{\"1\":{\"124\":1}}],[\"该api可以用来注册或获取全局指令\",{\"1\":{\"124\":1}}],[\"该api的实现非常简单\",{\"1\":{\"124\":1}}],[\"该api的内部实现原理\",{\"1\":{\"124\":1}}],[\"该api的原理同实例方法$set原理一样\",{\"1\":{\"124\":1}}],[\"该api的原理同实例方法\",{\"1\":{\"124\":2}}],[\"该名称在数据库中必须是唯一的\",{\"1\":{\"114\":1}}],[\"该索引就会被使用\",{\"1\":{\"103\":1}}],[\"该字段的值是从1开始自增\",{\"1\":{\"101\":1}}],[\"该字段中存放的值不能重复出现\",{\"1\":{\"81\":1}}],[\"该字段存放的值必须是null值之外的其他的具体值\",{\"1\":{\"80\":1}}],[\"该字段是否有默认值\",{\"1\":{\"68\":1}}],[\"该字段是否已经建立索引\",{\"1\":{\"68\":1}}],[\"该字段是否可以存储null值\",{\"1\":{\"68\":1}}],[\"该保存点之后创建的保存点也会被删除\",{\"1\":{\"13\":1}}],[\"才会创建数据表\",{\"1\":{\"64\":1}}],[\"才能看到事务的执行结果\",{\"1\":{\"5\":1}}],[\"会调用4个钩子函数中的start函数\",{\"1\":{\"147\":1}}],[\"会将\",{\"1\":{\"124\":1}}],[\"会将数据转换为对应时区时间后显示\",{\"1\":{\"62\":1}}],[\"会形成复合主键\",{\"1\":{\"85\":1}}],[\"会通过多个字段确保唯一性\",{\"1\":{\"82\":1}}],[\"会话结束后自动删除\",{\"1\":{\"64\":1}}],[\"临时表仅在当前会话可见\",{\"1\":{\"64\":1}}],[\"系统会根据当前系统所设置的时区\",{\"1\":{\"62\":1}}],[\"系统数据库\",{\"1\":{\"61\":1}}],[\"两个不同时区取出来的同一个日期和时间的显示结果可能不同\",{\"1\":{\"62\":1}}],[\"两种方式\",{\"1\":{\"21\":1}}],[\"后者代表0000年\",{\"1\":{\"62\":1}}],[\"0+版本中支持在数组上工作\",{\"1\":{\"124\":1}}],[\"0+版本中支持array+index用法\",{\"1\":{\"124\":1}}],[\"0不可以\",{\"1\":{\"109\":1}}],[\"0\",{\"1\":{\"62\":1,\"124\":4}}],[\"0900\",{\"1\":{\"58\":1}}],[\"取值范围0~30\",{\"1\":{\"62\":1}}],[\"取值范围0~65\",{\"1\":{\"62\":1}}],[\"小数部分位数\",{\"1\":{\"62\":1}}],[\"超出范围会报错\",{\"1\":{\"62\":1}}],[\"数组方法拦截器\",{\"0\":{\"139\":1}}],[\"数组的响应式\",{\"0\":{\"135\":1}}],[\"数学计算时浮点数也可能会损失精度\",{\"1\":{\"62\":1}}],[\"数据驱动视图\",{\"0\":{\"126\":1}}],[\"数据操作\",{\"0\":{\"91\":1}}],[\"数据操作语言\",{\"1\":{\"57\":1}}],[\"数据类型2\",{\"1\":{\"75\":1}}],[\"数据类型1\",{\"1\":{\"75\":1}}],[\"数据类型\",{\"1\":{\"62\":1,\"64\":2,\"73\":2,\"75\":1,\"76\":4,\"80\":5,\"82\":5,\"83\":2,\"85\":5,\"87\":3,\"89\":3,\"90\":2,\"106\":1}}],[\"数据控制语言\",{\"1\":{\"57\":1}}],[\"数据定义语言\",{\"1\":{\"57\":1}}],[\"数据查询语言\",{\"1\":{\"57\":1}}],[\"数据的操作有很大影响\",{\"1\":{\"38\":1}}],[\"数据库中只保存定义视图的sql语句\",{\"1\":{\"112\":1}}],[\"数据库系统会自动为这个字段插入指定的默认值\",{\"1\":{\"89\":1}}],[\"数据库的约束\",{\"0\":{\"79\":1}}],[\"数据库名称\",{\"1\":{\"59\":1,\"61\":1,\"63\":1,\"70\":2,\"71\":1}}],[\"数据库名和数据表名严格区分大小写\",{\"1\":{\"58\":1}}],[\"数据库名\",{\"1\":{\"58\":1}}],[\"数据库\",{\"0\":{\"56\":1}}],[\"数据库技术专家们提出了各种范式\",{\"1\":{\"38\":1}}],[\"数据库运行与维护\",{\"1\":{\"31\":1}}],[\"数据库实施\",{\"1\":{\"31\":1}}],[\"数据库设计对数据的存储性能\",{\"1\":{\"38\":1}}],[\"数据库设计范式\",{\"0\":{\"38\":1}}],[\"数据库设计人员只需考虑硬件\",{\"0\":{\"35\":1}}],[\"数据库设计人员需要分析用户的需求\",{\"0\":{\"32\":1}}],[\"数据库设计\",{\"0\":{\"30\":1}}],[\"数据表中字段对应的数据类型\",{\"1\":{\"68\":1}}],[\"数据表中字段的名称\",{\"1\":{\"68\":1}}],[\"数据表的名称\",{\"1\":{\"64\":1}}],[\"数据表名和字段名都不区分大小写\",{\"1\":{\"58\":1}}],[\"数据表基操\",{\"0\":{\"56\":1}}],[\"数据表等\",{\"0\":{\"36\":1}}],[\"数据表\",{\"1\":{\"10\":1}}],[\"数据响应式\",{\"1\":{\"1\":1}}],[\"year\",{\"1\":{\"62\":1}}],[\"日期和时间\",{\"1\":{\"62\":1}}],[\"vnode描述的节点有6种类型\",{\"1\":{\"154\":1}}],[\"vnode的作用\",{\"0\":{\"152\":1}}],[\"vnode的类型\",{\"0\":{\"151\":1}}],[\"vnode中包含了描述一个真实dom节点所需要的一系列属性\",{\"1\":{\"150\":1}}],[\"v1\",{\"1\":{\"124\":1}}],[\"v2\",{\"1\":{\"124\":1}}],[\"versions\",{\"1\":{\"124\":1}}],[\"version\",{\"1\":{\"124\":7}}],[\"vm\",{\"1\":{\"124\":1,\"134\":2}}],[\"vue中\",{\"1\":{\"150\":1}}],[\"vue中提供watcher\",{\"1\":{\"133\":1}}],[\"vue会把用户写在template中的类似于html的内容解析编译\",{\"1\":{\"143\":1}}],[\"vue提供了vue\",{\"1\":{\"142\":1}}],[\"vue必须作为第一个参数传入\",{\"1\":{\"124\":1}}],[\"vuecomponent\",{\"1\":{\"124\":1}}],[\"vue\",{\"1\":{\"124\":59}}],[\"vue源码解读\",{\"1\":{\"1\":1}}],[\"view语句中的select语句指定为多表查询的sql语句即可\",{\"1\":{\"116\":1}}],[\"view\",{\"1\":{\"114\":1,\"120\":1,\"121\":2,\"123\":1}}],[\"visible\",{\"1\":{\"109\":1}}],[\"validatecomponentname\",{\"1\":{\"124\":4}}],[\"value=this\",{\"1\":{\"134\":1}}],[\"value\",{\"1\":{\"122\":1,\"124\":3}}],[\"values和value表示值\",{\"1\":{\"93\":1}}],[\"values|value\",{\"1\":{\"93\":2,\"94\":1}}],[\"var\",{\"1\":{\"124\":6}}],[\"varchar或text类型的字段上\",{\"1\":{\"103\":1}}],[\"varchar变长\",{\"1\":{\"62\":1}}],[\"varchar\",{\"1\":{\"62\":1}}],[\"8字节\",{\"1\":{\"62\":1}}],[\"浮点数类型适合将小数作为近似值存储而不是作为精确值存储\",{\"1\":{\"62\":1}}],[\"浮点数类型的精度不高\",{\"1\":{\"62\":1}}],[\"浮点数\",{\"1\":{\"62\":1}}],[\"整数部分加小数部分的总长度\",{\"1\":{\"62\":1}}],[\"整数和小数超过15位就有可能损失精度\",{\"1\":{\"62\":1}}],[\"整数和小数超过6位就有可能损失精度\",{\"1\":{\"62\":1}}],[\"整数\",{\"1\":{\"62\":1}}],[\"整个过程就是先创建一个类sub\",{\"1\":{\"124\":1}}],[\"整个数据库设计的关键阶段\",{\"0\":{\"33\":1}}],[\"整个事务才算执行成功\",{\"1\":{\"3\":1}}],[\"整个操作都可以回滚\",{\"1\":{\"2\":1}}],[\"global\",{\"1\":{\"124\":2}}],[\"get\",{\"1\":{\"134\":1}}],[\"getter同时为每一个处理过的对象打上标识符\",{\"1\":{\"128\":1}}],[\"getter\",{\"1\":{\"124\":2,\"134\":1}}],[\"general\",{\"1\":{\"61\":1}}],[\"grant和commit和rollback\",{\"1\":{\"57\":1}}],[\"group\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1}}],[\"标签属性\",{\"1\":{\"147\":1}}],[\"标签属性attrs\",{\"1\":{\"147\":1}}],[\"标签名可以通过正则匹配的结果直接拿到\",{\"1\":{\"147\":1}}],[\"标签名\",{\"1\":{\"147\":1}}],[\"标签是否自闭合unary\",{\"1\":{\"147\":1}}],[\"标准的一条建库语句\",{\"1\":{\"61\":1}}],[\"标量子查询\",{\"0\":{\"51\":1}}],[\"和数字0\",{\"1\":{\"62\":1}}],[\"和\",{\"1\":{\"60\":1,\"124\":1}}],[\"可接受的参数是一个包含组件选项的对象\",{\"1\":{\"124\":1}}],[\"可选\",{\"1\":{\"114\":2}}],[\"可选值为\",{\"1\":{\"109\":1}}],[\"可选项\",{\"1\":{\"59\":3,\"60\":2,\"64\":4,\"70\":4,\"78\":2,\"106\":5}}],[\"可以实例出不同类型的虚拟dom节点\",{\"1\":{\"150\":1}}],[\"可以根据vue版本的不同从而做一些不同的事情\",{\"1\":{\"124\":1}}],[\"可以看到\",{\"1\":{\"124\":4}}],[\"可以使用加\",{\"1\":{\"96\":1}}],[\"可以任选其一\",{\"1\":{\"93\":1}}],[\"可以对数据表的单个或多个字段起约束作用\",{\"1\":{\"82\":1}}],[\"可以在getter中新增在setter中通知\",{\"1\":{\"132\":1}}],[\"可以在数据表中设置一个或者多个唯一约束\",{\"1\":{\"81\":1}}],[\"可以在事务中设置一个保存点\",{\"1\":{\"12\":1}}],[\"可以将保存点删除\",{\"1\":{\"12\":1}}],[\"可以将事务回滚到指定的保存点\",{\"1\":{\"12\":1}}],[\"可以将事务取消\",{\"1\":{\"9\":1}}],[\"例如nodeops\",{\"1\":{\"154\":1}}],[\"例如innodb和myisam支持btree\",{\"1\":{\"106\":1}}],[\"例如\",{\"1\":{\"58\":1,\"96\":1}}],[\"例如硬盘损坏\",{\"1\":{\"6\":1}}],[\"校对集等\",{\"1\":{\"64\":1}}],[\"校对集\",{\"1\":{\"58\":1}}],[\"字符串到render函数的流程\",{\"0\":{\"145\":1}}],[\"字符串类型\",{\"1\":{\"62\":1}}],[\"字符集\",{\"1\":{\"64\":1}}],[\"字符集信息\",{\"1\":{\"61\":1}}],[\"字符编码\",{\"1\":{\"58\":1}}],[\"字段列表\",{\"1\":{\"106\":4,\"107\":1,\"108\":4,\"114\":1}}],[\"字段值不会从1开始自增\",{\"1\":{\"101\":1}}],[\"字段\",{\"1\":{\"83\":1,\"85\":1}}],[\"字段设置非空约束后\",{\"1\":{\"80\":1}}],[\"字段相关的附加信息\",{\"1\":{\"68\":1}}],[\"字段的设置遵循\",{\"1\":{\"103\":1}}],[\"字段的数据类型\",{\"1\":{\"64\":1}}],[\"字段的名称\",{\"1\":{\"64\":1}}],[\"字段属性\",{\"1\":{\"64\":2,\"73\":1,\"74\":1,\"106\":1}}],[\"字段信息\",{\"1\":{\"61\":1}}],[\"字段名是要修改的字段的名称\",{\"1\":{\"97\":1}}],[\"字段名是指该表中设置了唯一约束的字段\",{\"1\":{\"84\":1}}],[\"字段名的顺序需要与值的顺序一一对应\",{\"1\":{\"93\":1}}],[\"字段名表示需要添加数据的字段名称\",{\"1\":{\"93\":1}}],[\"字段名3\",{\"1\":{\"82\":1}}],[\"字段名2=值2\",{\"1\":{\"93\":1,\"96\":1,\"97\":1}}],[\"字段名2\",{\"1\":{\"76\":2,\"77\":1,\"82\":3,\"85\":2,\"93\":1,\"94\":1}}],[\"字段名1=值1\",{\"1\":{\"93\":1,\"96\":1,\"97\":1}}],[\"字段名1\",{\"1\":{\"76\":3,\"77\":1,\"82\":3,\"85\":2,\"93\":1,\"94\":1}}],[\"字段名不区分大小写\",{\"1\":{\"58\":1}}],[\"字段名\",{\"1\":{\"42\":2,\"43\":1,\"44\":1,\"45\":2,\"47\":1,\"48\":1,\"51\":3,\"52\":2,\"53\":2,\"64\":2,\"74\":2,\"75\":1,\"76\":3,\"80\":7,\"83\":3,\"84\":1,\"85\":4,\"87\":4,\"89\":4,\"90\":3,\"106\":1}}],[\"字段不可再分\",{\"1\":{\"38\":1}}],[\"里面的参数可有可无\",{\"1\":{\"58\":1}}],[\"习惯上使用大写\",{\"1\":{\"58\":1}}],[\"提供字符串形式的\",{\"1\":{\"124\":1}}],[\"提交事务\",{\"1\":{\"57\":1}}],[\"提示内容\",{\"1\":{\"39\":1}}],[\"提示\",{\"1\":{\"39\":1,\"124\":4}}],[\"创建子节点\",{\"1\":{\"157\":1}}],[\"创建节点\",{\"0\":{\"154\":1}}],[\"创建注释类型的ast节点\",{\"1\":{\"147\":1}}],[\"创建profile实例\",{\"1\":{\"124\":1}}],[\"创建构造器\",{\"1\":{\"124\":1}}],[\"创建一个子类\",{\"1\":{\"124\":1}}],[\"创建语句\",{\"1\":{\"117\":1}}],[\"创建基于多表的视图时\",{\"1\":{\"116\":1}}],[\"创建索引时添加的注释信息\",{\"1\":{\"109\":1}}],[\"创建空间索引的字段\",{\"1\":{\"103\":1}}],[\"创建唯一性索引的字段允许有null值\",{\"1\":{\"103\":1}}],[\"创建数据表时可以设置列级或者表级的主键约束\",{\"1\":{\"85\":1}}],[\"创建数据表时设置唯一约束的方式有两种\",{\"1\":{\"82\":1}}],[\"创建数据表时设置\",{\"1\":{\"80\":1,\"82\":1,\"85\":1,\"87\":1,\"89\":1}}],[\"创建数据库前判断要创建的数据库的名称是否已经存在\",{\"1\":{\"59\":1}}],[\"创建\",{\"0\":{\"59\":1,\"105\":1,\"114\":1,\"116\":1},\"1\":{\"57\":1}}],[\"创建与查看\",{\"0\":{\"57\":1}}],[\"创建mysql配置文件\",{\"1\":{\"16\":1}}],[\"行子查询\",{\"0\":{\"53\":1}}],[\"与any左右相同\",{\"1\":{\"52\":1}}],[\"子查询返回的所有值都必须满足\",{\"1\":{\"52\":1}}],[\"子查询返回列表中\",{\"1\":{\"52\":1}}],[\"子查询\",{\"0\":{\"50\":1}}],[\"右外\",{\"0\":{\"48\":1}}],[\"右表的位置也相互替换\",{\"1\":{\"49\":1}}],[\"右表的全部加上左右两表的交集\",{\"1\":{\"48\":1}}],[\"右表\",{\"1\":{\"47\":1,\"48\":1}}],[\"of\",{\"1\":{\"124\":1}}],[\"observer类中\",{\"1\":{\"140\":1}}],[\"observable\",{\"1\":{\"124\":3}}],[\"ob\",{\"1\":{\"128\":1}}],[\"object|array\",{\"1\":{\"124\":1}}],[\"object\",{\"1\":{\"124\":23}}],[\"options传给之后的所有vue实例\",{\"1\":{\"124\":1}}],[\"options合并即可\",{\"1\":{\"124\":1}}],[\"options属性进而影响之后的所有vue实例\",{\"1\":{\"124\":1}}],[\"options属性\",{\"1\":{\"124\":1}}],[\"options\",{\"1\":{\"124\":42}}],[\"option\",{\"1\":{\"114\":2}}],[\"or\",{\"1\":{\"72\":1,\"73\":1,\"74\":1,\"76\":1,\"111\":1,\"114\":2,\"121\":1}}],[\"order\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1}}],[\"outer\",{\"1\":{\"47\":1,\"48\":1}}],[\"only\",{\"1\":{\"70\":2}}],[\"on\",{\"1\":{\"43\":1,\"44\":1,\"47\":1,\"48\":1,\"107\":1,\"111\":2,\"124\":1}}],[\"则说明是条件注释\",{\"1\":{\"147\":1}}],[\"则将游标移动到\",{\"1\":{\"147\":1}}],[\"则shouldkeepcomment为true\",{\"1\":{\"147\":1}}],[\"则把html从第4位\",{\"1\":{\"147\":1}}],[\"则创建注释类型的ast节点\",{\"1\":{\"147\":1}}],[\"则创建纯静态文本类型的ast节点\",{\"1\":{\"147\":1}}],[\"则创建动态文本类型的ast节点\",{\"1\":{\"147\":1}}],[\"则直接返回\",{\"1\":{\"124\":1}}],[\"则使用组件id作为组件的name属性\",{\"1\":{\"124\":1}}],[\"则使用vue\",{\"1\":{\"124\":1}}],[\"则表示本次操作为注册组件\",{\"1\":{\"124\":1}}],[\"则表示本次操作为注册过滤器\",{\"1\":{\"124\":1}}],[\"则表示本次操作为获取组件\",{\"1\":{\"124\":1}}],[\"则表示本次操作为获取过滤器\",{\"1\":{\"124\":1}}],[\"则表示为注册指令\",{\"1\":{\"124\":1}}],[\"则表示为获取指令\",{\"1\":{\"124\":1}}],[\"则默认监听bind和update两个事件\",{\"1\":{\"124\":1}}],[\"则返回一个\",{\"1\":{\"124\":1}}],[\"则不进行检查\",{\"1\":{\"114\":1}}],[\"则不会自动增长值\",{\"1\":{\"88\":1}}],[\"则会将表中所有数据的指定字段全部更新\",{\"1\":{\"97\":1}}],[\"则值的顺序与指定的字段名顺序一致\",{\"1\":{\"94\":1}}],[\"则值的顺序要与数据表的字段顺序一致\",{\"1\":{\"94\":1}}],[\"则下次自动增长的值为字段中的最大值加1\",{\"1\":{\"88\":1}}],[\"则该字段会使用自动增长值\",{\"1\":{\"88\":1}}],[\"则按照like子句的匹配结果或者where子句的匹配结果查看数据表\",{\"1\":{\"66\":1}}],[\"则左表中对应字段的值显示为null\",{\"1\":{\"48\":1}}],[\"则右表中对应字段的值显示为null\",{\"1\":{\"47\":1}}],[\"则需要显式地开启事务\",{\"1\":{\"7\":1}}],[\"查看视图的创建语句\",{\"0\":{\"120\":1}}],[\"查看视图的状态信息\",{\"0\":{\"119\":1}}],[\"查看视图的字段信息\",{\"0\":{\"118\":1}}],[\"查看视图\",{\"0\":{\"117\":1}}],[\"查看索引的结果中每个字段的含义\",{\"1\":{\"109\":1}}],[\"查看索引\",{\"0\":{\"109\":1}}],[\"查看建表语句的同时也可以看到索引信息\",{\"1\":{\"109\":1}}],[\"查看建表语句\",{\"0\":{\"67\":1}}],[\"查看建库语句\",{\"1\":{\"61\":1}}],[\"查看数据表\",{\"0\":{\"66\":1}}],[\"查看所有的存储引擎\",{\"0\":{\"65\":1}}],[\"查看所有数据库的基本语法\",{\"1\":{\"60\":1}}],[\"查看指定数据库的创建信息基本语法\",{\"1\":{\"61\":1}}],[\"查看\",{\"0\":{\"60\":1}}],[\"查看当前会话的autocommit值\",{\"1\":{\"11\":1}}],[\"查询结果中包括右表中的所有记录\",{\"1\":{\"48\":1}}],[\"查询结果中包括左表中的所有记录\",{\"1\":{\"47\":1}}],[\"用js模拟出一个dom节点\",{\"1\":{\"150\":1}}],[\"用js的计算性能来换取操作dom所消耗的性能\",{\"1\":{\"150\":1}}],[\"用一个对象来描述一个dom节点\",{\"1\":{\"150\":1}}],[\"用来拦截数组实例与array\",{\"1\":{\"139\":1}}],[\"用来存储已安装过的插件\",{\"1\":{\"124\":1}}],[\"用法\",{\"1\":{\"124\":1}}],[\"用于简单的场景\",{\"1\":{\"124\":1}}],[\"用于视图数据操作时的检查条件\",{\"1\":{\"114\":1}}],[\"用于声明执行视图时的访问权限\",{\"1\":{\"114\":1}}],[\"用于声明mysql处理视图的方式\",{\"1\":{\"114\":1}}],[\"用于控制是否允许修改数据库及其中的数据\",{\"1\":{\"70\":1}}],[\"用于为数据库加密\",{\"1\":{\"70\":1}}],[\"用于为不同字符集指定比较和排序规则\",{\"1\":{\"58\":1}}],[\"用于指定校对集\",{\"1\":{\"70\":1}}],[\"用于指定默认的数据库字符集\",{\"1\":{\"70\":1}}],[\"用于保存确切精度的小数\",{\"1\":{\"62\":1}}],[\"用于保存小数\",{\"1\":{\"62\":1}}],[\"用于存储系统性能相关的动态参数\",{\"1\":{\"61\":1}}],[\"用于判断满足给定条件的记录是否存在\",{\"1\":{\"55\":1}}],[\"用右表的记录匹配左表的记录\",{\"1\":{\"48\":1}}],[\"用左表的记录匹配右表的记录\",{\"1\":{\"47\":1}}],[\"用户名\",{\"1\":{\"114\":1}}],[\"用户输入的字符会按照一定的规则转换为二进制后保存\",{\"1\":{\"58\":1}}],[\"用户自定义的名称习惯上使用小写\",{\"1\":{\"58\":1}}],[\"用户授权\",{\"1\":{\"57\":1}}],[\"用户\",{\"1\":{\"28\":1}}],[\"用户需要手动提交\",{\"1\":{\"8\":1}}],[\"用户执行的每一条sql语句都会被当成单独的事务自动提交\",{\"1\":{\"7\":1,\"11\":1}}],[\"左表\",{\"1\":{\"47\":1,\"48\":1}}],[\"左表的全部加上左右两表的交集\",{\"1\":{\"47\":1}}],[\"左外连接查询和右外连接查询是可以相互替换的\",{\"1\":{\"49\":1}}],[\"左外\",{\"0\":{\"47\":1}}],[\"外连接\",{\"0\":{\"46\":1}}],[\"要和第一张表中的字段数一致\",{\"1\":{\"45\":1}}],[\"要求一张数据表中每一列数据都和主键直接相关\",{\"1\":{\"38\":1}}],[\"多条\",{\"0\":{\"94\":1}}],[\"多个值之间使用英文逗号分隔\",{\"1\":{\"93\":1}}],[\"多个字段名之间使用英文逗号分隔\",{\"1\":{\"93\":1}}],[\"多个联合查询的字段数量必须一致\",{\"1\":{\"45\":1}}],[\"多行注释\",{\"1\":{\"58\":1}}],[\"多选一\",{\"1\":{\"52\":1}}],[\"多表操作\",{\"0\":{\"40\":1}}],[\"联合查询的字段来源于第一条查询语句\",{\"1\":{\"45\":1}}],[\"联合查询\",{\"0\":{\"45\":1}}],[\"别名\",{\"1\":{\"54\":1}}],[\"别名2\",{\"1\":{\"44\":1}}],[\"别名1\",{\"1\":{\"44\":1}}],[\"自动调用\",{\"1\":{\"124\":1}}],[\"自动增长值不会减少或者填补空缺\",{\"1\":{\"88\":1}}],[\"自动为默认用户root生成随机密码\",{\"1\":{\"21\":1}}],[\"自定义函数等信息\",{\"1\":{\"61\":1}}],[\"自连接查询必须为表设置别名\",{\"1\":{\"44\":1}}],[\"自查询\",{\"0\":{\"44\":1}}],[\"保存两个表中交集部分\",{\"1\":{\"43\":1}}],[\"保存点名\",{\"1\":{\"12\":3}}],[\"内部会调用createastelement函数来创建元素类型的ast节点\",{\"1\":{\"147\":1}}],[\"内部会用它来处理\",{\"1\":{\"124\":1}}],[\"内连接查询\",{\"0\":{\"43\":1}}],[\"内置组件\",{\"1\":{\"1\":1}}],[\"简写\",{\"1\":{\"42\":1,\"118\":1}}],[\"表级主键约束是指对单字段或者多字段设置\",{\"1\":{\"85\":1}}],[\"表级\",{\"1\":{\"82\":1,\"85\":1}}],[\"表级约束独立于字段\",{\"1\":{\"82\":1}}],[\"表选项\",{\"1\":{\"64\":2}}],[\"表子查询多位于from关键字之后\",{\"1\":{\"54\":1}}],[\"表子查询\",{\"0\":{\"54\":1},\"1\":{\"54\":1}}],[\"表名是要删除的数据表名称\",{\"1\":{\"99\":1}}],[\"表名2\",{\"1\":{\"78\":1}}],[\"表名1\",{\"1\":{\"78\":1}}],[\"表名\",{\"1\":{\"47\":1,\"48\":1,\"51\":2,\"52\":2,\"53\":2,\"55\":2,\"64\":2,\"67\":1,\"68\":1,\"73\":2,\"74\":2,\"75\":2,\"76\":4,\"77\":1,\"80\":5,\"82\":2,\"83\":3,\"84\":1,\"85\":5,\"86\":1,\"87\":3,\"89\":3,\"93\":3,\"94\":1,\"96\":1,\"97\":1,\"99\":1,\"100\":1,\"101\":1,\"106\":1,\"107\":1,\"108\":1,\"109\":1,\"111\":4}}],[\"表示所有节点都已经遍历过了\",{\"1\":{\"159\":1}}],[\"表示从某个数据表或视图中查出满足条件的记录\",{\"1\":{\"114\":1}}],[\"表示要创建的视图名称\",{\"1\":{\"114\":1}}],[\"表示要修改哪个数据库\",{\"1\":{\"70\":1}}],[\"表示空间索引\",{\"1\":{\"106\":1}}],[\"表示全文索引\",{\"1\":{\"106\":1}}],[\"表示唯一性索引\",{\"1\":{\"106\":1}}],[\"表示为创建的索引定义的名称\",{\"1\":{\"106\":1}}],[\"表示索引\",{\"1\":{\"106\":1}}],[\"表示在原基础上加1\",{\"1\":{\"96\":1}}],[\"表示在删除之前判断数据表是否存在\",{\"1\":{\"78\":1}}],[\"表示给字段添加了唯一约束\",{\"1\":{\"83\":1}}],[\"表示删除临时表\",{\"1\":{\"78\":1}}],[\"表示查看当前数据库中所有的数据表\",{\"1\":{\"66\":1}}],[\"表示临时表\",{\"1\":{\"64\":1}}],[\"表示匹配一个字符\",{\"1\":{\"60\":1}}],[\"表示匹配一个或多个字符\",{\"1\":{\"60\":1}}],[\"表示创建数据库\",{\"1\":{\"59\":1}}],[\"表示选择项\",{\"1\":{\"58\":1}}],[\"表示可选项\",{\"1\":{\"58\":1}}],[\"表示去除查询结果中完全重复的数据\",{\"1\":{\"45\":1}}],[\"表示保留所有查询结果\",{\"1\":{\"45\":1}}],[\"表2\",{\"1\":{\"42\":2,\"43\":1,\"45\":1}}],[\"表1\",{\"1\":{\"42\":2,\"43\":1,\"44\":2,\"45\":1}}],[\"fnoptions分别用来表示函数式组件对应的vue实例\",{\"1\":{\"151\":1}}],[\"foreach\",{\"1\":{\"124\":3}}],[\"form\",{\"1\":{\"38\":1}}],[\"further\",{\"1\":{\"124\":1}}],[\"function\",{\"1\":{\"124\":32}}],[\"fulltext\",{\"1\":{\"106\":1,\"109\":1}}],[\"fulltext|spatial\",{\"1\":{\"106\":1,\"108\":1}}],[\"filter和vue\",{\"1\":{\"124\":1}}],[\"filter=\",{\"1\":{\"124\":2}}],[\"filters\",{\"1\":{\"124\":5}}],[\"filter\",{\"1\":{\"124\":8}}],[\"firstname\",{\"1\":{\"124\":2}}],[\"first\",{\"1\":{\"76\":2}}],[\"first参数\",{\"1\":{\"75\":1}}],[\"first|after\",{\"1\":{\"75\":1}}],[\"field\",{\"1\":{\"68\":1}}],[\"float类型的数字\",{\"1\":{\"62\":1}}],[\"float\",{\"1\":{\"62\":1}}],[\"from\",{\"1\":{\"42\":2,\"43\":1,\"44\":1,\"45\":2,\"47\":1,\"48\":1,\"51\":2,\"52\":2,\"53\":2,\"54\":1,\"55\":2,\"99\":1,\"100\":1,\"109\":1,\"110\":1}}],[\"||\",{\"1\":{\"124\":8}}],[\"|where\",{\"1\":{\"60\":1,\"66\":1}}],[\"|字段名\",{\"1\":{\"54\":1,\"55\":1}}],[\"|字段\",{\"1\":{\"52\":1}}],[\"|\",{\"1\":{\"42\":2,\"43\":1,\"44\":1,\"45\":2,\"51\":1,\"53\":1,\"58\":1,\"106\":4,\"108\":3,\"114\":4,\"124\":6}}],[\"完整写法\",{\"1\":{\"42\":1}}],[\"完成实体\",{\"0\":{\"34\":1}}],[\"危险内容\",{\"1\":{\"39\":1}}],[\"危险\",{\"1\":{\"39\":1}}],[\"警告内容\",{\"1\":{\"39\":1}}],[\"警告\",{\"1\":{\"39\":1}}],[\"连接条件\",{\"1\":{\"43\":1,\"44\":1,\"47\":1,\"48\":1}}],[\"连接查询\",{\"0\":{\"41\":1}}],[\"连接\",{\"1\":{\"39\":1}}],[\"投影\",{\"1\":{\"39\":1}}],[\"选择数据库\",{\"0\":{\"63\":1}}],[\"选择\",{\"1\":{\"39\":1}}],[\"除了组件节点的属性外\",{\"1\":{\"151\":1}}],[\"除了具备元素节点的属性外\",{\"1\":{\"151\":1}}],[\"除\",{\"1\":{\"39\":1,\"96\":1}}],[\"差\",{\"1\":{\"39\":1}}],[\"交叉连接查询\",{\"0\":{\"42\":1}}],[\"交\",{\"1\":{\"39\":1}}],[\"并所处的位置也相同\",{\"1\":{\"157\":1}}],[\"并且会在发生改变时触发相应的更新\",{\"1\":{\"124\":1}}],[\"并且会影响之后的所有vue实例\",{\"1\":{\"124\":1}}],[\"并且使用toarray方法将其转换成数组\",{\"1\":{\"124\":1}}],[\"并且我们知道了\",{\"1\":{\"124\":1}}],[\"并且在options属性中添加了directives属性\",{\"1\":{\"124\":1}}],[\"并且在创建和维护索引时\",{\"1\":{\"103\":1}}],[\"并确保这个新属性同样是响应式的\",{\"1\":{\"124\":1}}],[\"并挂载到一个元素上\",{\"1\":{\"124\":1}}],[\"并\",{\"1\":{\"39\":1}}],[\"并进行试运行\",{\"0\":{\"36\":1}}],[\"笛卡儿积\",{\"1\":{\"39\":1}}],[\"集合运算符\",{\"1\":{\"39\":1}}],[\"关于该方法在数据变化侦测篇已经做了非常详细的介绍\",{\"1\":{\"124\":1}}],[\"关于compiletofunctions方法在模板编译篇已经做了非常详细的介绍\",{\"1\":{\"124\":1}}],[\"关键词如何被压缩\",{\"1\":{\"109\":1}}],[\"关键字into可以省略\",{\"1\":{\"93\":1}}],[\"关键字不能直接作为用户自定义名称使用\",{\"1\":{\"58\":1}}],[\"关键字不区分大小写\",{\"1\":{\"58\":1}}],[\"关系运算符\",{\"1\":{\"39\":1}}],[\"关系代数\",{\"0\":{\"39\":1}}],[\"关闭后需要手动提交事务\",{\"1\":{\"11\":1}}],[\"关闭当前会话的事务自动提交\",{\"1\":{\"11\":1}}],[\"而是从两边向中间进行查找\",{\"1\":{\"159\":1}}],[\"而是对比新旧子节点中特殊的位置的子节点\",{\"1\":{\"159\":1}}],[\"而是保持原有的自动增长值\",{\"1\":{\"101\":1}}],[\"而不是插入到所有已处理节点之后\",{\"1\":{\"157\":1}}],[\"而不需要更新的地方则不需关心\",{\"1\":{\"150\":1}}],[\"而不能间接相关\",{\"1\":{\"38\":1}}],[\"而parsehtml是用来解析模板字符串的\",{\"1\":{\"147\":1}}],[\"而文本信息与过滤器信息又存在于html标签中\",{\"1\":{\"146\":1}}],[\"而vnode再经过patch过程从而得到将要渲染的视图中的vnode\",{\"1\":{\"143\":1}}],[\"而render函数会将模板内容生成对应的vnode\",{\"1\":{\"143\":1}}],[\"而且执行这类操作时会隐式地提交事务\",{\"1\":{\"10\":1}}],[\"非空约束可以在创建数据表时设置\",{\"1\":{\"80\":1}}],[\"非空约束通过not\",{\"1\":{\"80\":1}}],[\"非空约束用于确保插入到字段中值的非空性\",{\"1\":{\"80\":1}}],[\"非空约束\",{\"0\":{\"80\":1}}],[\"非主键字段需完全依赖主键\",{\"1\":{\"38\":1}}],[\"非明文\",{\"1\":{\"25\":1}}],[\"第二个指针指向最后一个元素的下标\",{\"1\":{\"159\":1}}],[\"第二个参数提供了一些解析html模板时的一些参数\",{\"1\":{\"147\":1}}],[\"第二范式遵从唯一性\",{\"1\":{\"38\":1}}],[\"第一个指针指向第一个元素的下标\",{\"1\":{\"159\":1}}],[\"第一个参数是待转换的模板字符串\",{\"1\":{\"147\":1}}],[\"第一范式遵从原子性\",{\"1\":{\"38\":1}}],[\"第n条记录的值2\",{\"1\":{\"94\":1}}],[\"第n条记录的值1\",{\"1\":{\"94\":1}}],[\"第2条记录的值2\",{\"1\":{\"94\":1}}],[\"第2条记录的值1\",{\"1\":{\"94\":1}}],[\"第1条记录的值2\",{\"1\":{\"94\":1}}],[\"第1条记录的值1\",{\"1\":{\"94\":1}}],[\"第三范式就是非主键字段不能相互依赖\",{\"1\":{\"38\":1}}],[\"对所有节点操作进行了封装\",{\"1\":{\"154\":1}}],[\"对应到代码中就是options\",{\"1\":{\"147\":1}}],[\"对象是通过setter来实现对数据进行了操作\",{\"1\":{\"138\":1}}],[\"对象的响应式是通过js原生提供的对象方法实现\",{\"1\":{\"136\":1}}],[\"对象的响应式是通过object\",{\"1\":{\"128\":1}}],[\"对象的响应式\",{\"0\":{\"128\":1}}],[\"对于日常业务开发几乎用不到\",{\"1\":{\"124\":1}}],[\"对于复合主键而言\",{\"1\":{\"38\":1}}],[\"对日期和时间进行转换后存放\",{\"1\":{\"62\":1}}],[\"对数据的操作都会立即生效\",{\"1\":{\"10\":1}}],[\"实体的字段完全依赖于主键\",{\"1\":{\"38\":1}}],[\"实例方法\",{\"1\":{\"1\":1}}],[\"即可以修改vue\",{\"1\":{\"124\":1}}],[\"即可得到相同的结果\",{\"1\":{\"49\":1}}],[\"即已被安装过\",{\"1\":{\"124\":1}}],[\"即将definition函数分别赋给bind和update两个属性\",{\"1\":{\"124\":1}}],[\"即使新字段的数据类型与旧字段的数据类型相同\",{\"1\":{\"73\":1}}],[\"即列的名称\",{\"1\":{\"68\":1}}],[\"即数据表中不能有重复的字段\",{\"1\":{\"38\":1}}],[\"即回滚\",{\"1\":{\"9\":1}}],[\"指针才会向中间进行移动\",{\"1\":{\"159\":1}}],[\"指一个完整的select语句\",{\"1\":{\"114\":1}}],[\"指定字段可以是表中的全部字段或部分字段\",{\"1\":{\"93\":1}}],[\"指定字段名2\",{\"1\":{\"53\":1}}],[\"指定字段名1\",{\"1\":{\"53\":1}}],[\"指定匹配模式\",{\"1\":{\"60\":1}}],[\"指定校对集\",{\"1\":{\"59\":1}}],[\"指定数据库字符集\",{\"1\":{\"59\":1}}],[\"指数据表的每一列都是不可分割的基本数据项\",{\"1\":{\"38\":1}}],[\"指令id和指令的定义\",{\"1\":{\"124\":1}}],[\"指令函数\",{\"1\":{\"124\":1}}],[\"指令\",{\"1\":{\"1\":1}}],[\"nexttick\",{\"1\":{\"124\":4}}],[\"newperperty=\",{\"1\":{\"124\":1}}],[\"new\",{\"1\":{\"124\":3}}],[\"net\",{\"1\":{\"22\":1,\"23\":1,\"29\":1}}],[\"name\",{\"1\":{\"109\":2,\"124\":13}}],[\"number\",{\"1\":{\"124\":3}}],[\"numberic\",{\"1\":{\"62\":1}}],[\"null没有\",{\"1\":{\"109\":1}}],[\"null来实现\",{\"1\":{\"80\":1}}],[\"null\",{\"1\":{\"68\":1,\"80\":3,\"103\":1,\"109\":1,\"124\":12}}],[\"node\",{\"1\":{\"124\":4}}],[\"non\",{\"1\":{\"109\":1}}],[\"not\",{\"1\":{\"52\":1,\"59\":2,\"64\":2,\"80\":3}}],[\"normal\",{\"1\":{\"38\":1}}],[\"概念\",{\"1\":{\"38\":1}}],[\"概念结构设计\",{\"1\":{\"31\":1}}],[\"备份和升级等工作\",{\"0\":{\"37\":1}}],[\"编写与调试应用程序\",{\"0\":{\"36\":1}}],[\"设计人员根据逻辑设计和物理设计的结果建立数据库\",{\"0\":{\"36\":1}}],[\"设置的值\",{\"1\":{\"124\":1}}],[\"设置默认值约束\",{\"0\":{\"89\":1}}],[\"设置auto\",{\"1\":{\"88\":2}}],[\"设置字段自动增长\",{\"0\":{\"87\":1}}],[\"设置唯一约束后\",{\"1\":{\"81\":1}}],[\"设置数据表的相关选项\",{\"1\":{\"64\":1}}],[\"设置约束属性保证数据的完整性和有效性\",{\"1\":{\"64\":1}}],[\"设置comment属性给字段添加备注\",{\"1\":{\"64\":1}}],[\"设置保存点后\",{\"1\":{\"12\":1}}],[\"设置为0表示关闭事务自动提交\",{\"1\":{\"11\":1}}],[\"535字节\",{\"1\":{\"62\":1}}],[\"5\",{\"0\":{\"36\":1}}],[\"承担了大部分任务\",{\"0\":{\"35\":1}}],[\"通知依赖的方法\",{\"1\":{\"132\":1}}],[\"通常情况下使用values\",{\"1\":{\"93\":1}}],[\"通常数据库管理系统为了保证其独立性与可移植性\",{\"0\":{\"35\":1}}],[\"通过实例化时传入的属性参数不同主要可以搭配为以下的几种类型的节点\",{\"1\":{\"151\":1}}],[\"通过属性之间不同的搭配就可以描述出各种类型的真实dom节点\",{\"1\":{\"150\":1}}],[\"通过dom\",{\"1\":{\"150\":1}}],[\"通过把数据的\",{\"1\":{\"139\":1}}],[\"通过递归来将对象中的每一个属性添加setter\",{\"1\":{\"128\":1}}],[\"通过一个oberver类来将一个对象转换为响应式\",{\"1\":{\"128\":1}}],[\"通过对比数据变化前后的状态\",{\"1\":{\"150\":1}}],[\"通过对vue\",{\"1\":{\"124\":1}}],[\"通过对用户的需求进行综合\",{\"0\":{\"33\":1}}],[\"通过视图操作基本表的方式与直接操作数据表的方式一样\",{\"1\":{\"122\":1}}],[\"通过视图来操作数据\",{\"0\":{\"122\":1}}],[\"通过视图不仅可以看到基本表中的数据\",{\"1\":{\"112\":1}}],[\"通过where子句可以指定删除数据的条件\",{\"1\":{\"99\":1}}],[\"通过alter\",{\"1\":{\"80\":1}}],[\"通过show\",{\"1\":{\"66\":1}}],[\"通过\",{\"1\":{\"60\":1}}],[\"通过更改autocommit的值设置事务的提交方式\",{\"1\":{\"11\":1}}],[\"通过日志记录数据库的所有变化\",{\"1\":{\"4\":1}}],[\"为什么说是类似html内容\",{\"1\":{\"143\":1}}],[\"为什么对象和数组是两个分开实现\",{\"0\":{\"136\":1}}],[\"为每一个依赖创建一个watcher实例数据再变化时就通知对应的watcher由该实例通知对应的依赖当创建watcher实例时会把自己添加到这个依赖管理器中\",{\"1\":{\"133\":1}}],[\"为已有的数据表创建索引\",{\"0\":{\"107\":1}}],[\"为多字段设置主键约束时\",{\"1\":{\"85\":1}}],[\"为数据表建立索引以加快数据的查询效率\",{\"1\":{\"103\":1}}],[\"为数据表建立视图以提高数据的安全性\",{\"1\":{\"103\":1}}],[\"为数据表建立事务以确保一组sql语句操作数据的完整性\",{\"1\":{\"103\":1}}],[\"为数据表创建索引可以快速找到目标数据\",{\"1\":{\"102\":1}}],[\"为数据表添加指定字段\",{\"0\":{\"75\":1}}],[\"为数据表选择合适的存储引擎\",{\"0\":{\"35\":1}}],[\"为了充分了解某个视图的信息\",{\"1\":{\"117\":1}}],[\"为了规范化数据库\",{\"1\":{\"38\":1}}],[\"为了避免不规范的数据造成数据冗余\",{\"1\":{\"38\":1}}],[\"为字段选择合适的数据类型\",{\"0\":{\"35\":1}}],[\"为逻辑数据模型确定数据库的存储结构\",{\"0\":{\"35\":1}}],[\"为事务恢复提供跟踪记录\",{\"1\":{\"4\":1}}],[\"4字节\",{\"1\":{\"62\":1}}],[\"4\",{\"0\":{\"35\":1},\"1\":{\"42\":1,\"57\":1}}],[\"如props\",{\"1\":{\"151\":1}}],[\"如不保留注释\",{\"1\":{\"147\":1}}],[\"如何解析不同的内容\",{\"1\":{\"147\":1}}],[\"如何将自己添加到对应的管理器中\",{\"0\":{\"134\":1}}],[\"如下\",{\"1\":{\"124\":12}}],[\"如字段值都被索引则sub\",{\"1\":{\"109\":1}}],[\"如存储引擎\",{\"1\":{\"64\":1}}],[\"如插入日期和时间时\",{\"1\":{\"62\":1}}],[\"如全局变量\",{\"1\":{\"61\":1}}],[\"如用户的权限\",{\"1\":{\"61\":1}}],[\"如用户表信息\",{\"1\":{\"61\":1}}],[\"如\",{\"1\":{\"58\":1,\"159\":1}}],[\"如使用sql语句创建数据库\",{\"0\":{\"36\":1}}],[\"如关系模型\",{\"0\":{\"34\":1}}],[\"如果上面都不满足\",{\"1\":{\"159\":1}}],[\"如果相同那就直接进入更新节点的操作\",{\"1\":{\"159\":1}}],[\"如果相同那就直接进行更新节点的操作\",{\"1\":{\"159\":1}}],[\"如果相同\",{\"1\":{\"159\":1}}],[\"如果相同直接进行更新节点的操作\",{\"1\":{\"159\":1}}],[\"如果把新的子节点数组里面的每个子节点都循环完毕后\",{\"1\":{\"157\":1}}],[\"如果新旧的vnode里都包含子节点\",{\"1\":{\"156\":1}}],[\"如果新的子节点数组里面的某个子节点在旧的子节点数组里面找到了与之相同的子节点\",{\"1\":{\"157\":1}}],[\"如果新的子节点数组里面的某个子节点在旧的子节点数组里面找不到与之对应的子节点\",{\"1\":{\"157\":1}}],[\"如果新的子节点里面的某个子节点在旧的子节点数组中找到了与之相同的子节点\",{\"1\":{\"157\":1}}],[\"如果新的vnode是元素节点\",{\"1\":{\"156\":1}}],[\"如果新的vnode是文本节点表示这个节点的内容是纯文本\",{\"1\":{\"156\":1}}],[\"如果新的vnode是文本节点\",{\"1\":{\"156\":1}}],[\"如果新的vnode和旧的vnode均为静态节点\",{\"1\":{\"156\":1}}],[\"如果新的没有的而旧的有那么就把旧的vnode上有的移除\",{\"1\":{\"153\":1}}],[\"如果新的有的而旧的没有那么在旧的vnode上添加\",{\"1\":{\"153\":1}}],[\"如果为空节点\",{\"1\":{\"156\":1}}],[\"如果为自动增长字段插入null值\",{\"1\":{\"88\":1}}],[\"如果旧的vnode中是文本节点\",{\"1\":{\"156\":1}}],[\"如果旧的vnode不包含子节点\",{\"1\":{\"156\":1}}],[\"如果旧的vnode不是文本节点\",{\"1\":{\"156\":1}}],[\"如果旧的vnode里也包含了子节点那就需要递归对比更新子节点\",{\"1\":{\"156\":1}}],[\"如果既不是元素节点\",{\"1\":{\"154\":1}}],[\"如果有子节点那么就会递归遍历创建所有子节点\",{\"1\":{\"154\":1}}],[\"如果有tag属性即认为是元素节点\",{\"1\":{\"154\":1}}],[\"如果某些节点在新的vnode和旧的vnode上都有\",{\"1\":{\"153\":1}}],[\"如果用户配置了comments选项为true\",{\"1\":{\"147\":1}}],[\"如果模板字符串html符合注释开始的正则\",{\"1\":{\"147\":1}}],[\"如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析\",{\"1\":{\"146\":1}}],[\"如果碰到文本中包含过滤器那就调用过滤器解析器来解析\",{\"1\":{\"146\":1}}],[\"如果给一个且通过下表来操作数组元素那么vue也监测不到不具备响应式\",{\"1\":{\"141\":1}}],[\"如果给一个对象新增一个属性或删除vue是监测不到就意味着该属性不具备响应式\",{\"1\":{\"141\":1}}],[\"如果传入的插件是一个函数\",{\"1\":{\"124\":1}}],[\"如果传入了definition参数\",{\"1\":{\"124\":3}}],[\"如果存在的话\",{\"1\":{\"124\":1}}],[\"如果插件是一个函数\",{\"1\":{\"124\":1}}],[\"如果插件是一个对象\",{\"1\":{\"124\":1}}],[\"如果插入了一个大于自动增长值的具体值\",{\"1\":{\"88\":1}}],[\"如果插入的是一个具体的值\",{\"1\":{\"88\":1}}],[\"如果是\",{\"1\":{\"156\":1}}],[\"如果是动态文本\",{\"1\":{\"147\":1}}],[\"如果是对象\",{\"1\":{\"124\":1}}],[\"如果是注册组件\",{\"1\":{\"124\":1}}],[\"如果是函数\",{\"1\":{\"124\":1}}],[\"如果definition参数不是一个函数\",{\"1\":{\"124\":1}}],[\"如果对象是响应式的\",{\"1\":{\"124\":1}}],[\"如果没有传入definition参数\",{\"1\":{\"124\":3}}],[\"如果没有提供回调且在支持\",{\"1\":{\"124\":1}}],[\"如果没有被压缩为null\",{\"1\":{\"109\":1}}],[\"如果没有给这个字段赋值\",{\"1\":{\"89\":1}}],[\"如果索引为主键索引\",{\"1\":{\"109\":1}}],[\"如果字段值设置了auto\",{\"1\":{\"101\":1}}],[\"如果字段的key列值为uni\",{\"1\":{\"83\":1}}],[\"如果想要在原字段值的基础上更新\",{\"1\":{\"96\":1}}],[\"如果想要将一组sql语句作为一个事务\",{\"1\":{\"7\":1}}],[\"如果指定了字段名\",{\"1\":{\"94\":1}}],[\"如果未指定字段名\",{\"1\":{\"94\":1}}],[\"如果未提交事务直接终止mysql会话\",{\"1\":{\"11\":1}}],[\"如果省略definer子句\",{\"1\":{\"114\":1}}],[\"如果省略字段\",{\"1\":{\"93\":1}}],[\"如果省略使用默认字符集\",{\"1\":{\"59\":1}}],[\"如果值的数量或顺序与数据表定义的字段数量或顺序不同\",{\"1\":{\"93\":1}}],[\"如果添加可选项\",{\"1\":{\"66\":1}}],[\"如果要在数据库中使用emoji表情\",{\"1\":{\"58\":1}}],[\"如果要使用可以通过反引号包裹\",{\"1\":{\"58\":1}}],[\"如果右表的某条记录在左表中不存在\",{\"1\":{\"48\":1}}],[\"如果左表的某条记录在右表中不存在\",{\"1\":{\"47\":1}}],[\"如果不同\",{\"1\":{\"159\":1}}],[\"如果不同再把新的子节点数组中所有未处理子节点的最后一个子节点与旧的子节点数组中所有未处理子节点的第一个子节点进行对比\",{\"1\":{\"159\":1}}],[\"如果不同再把新的子节点数组中所有未处理子节点的最后一个子节点与旧的子节点数组中所有未处理子节点的最后一个子节点对比\",{\"1\":{\"159\":1}}],[\"如果不同则把旧的vnode里的文本改为和新的文本一样\",{\"1\":{\"156\":1}}],[\"如果不是动态文本\",{\"1\":{\"147\":1}}],[\"如果不添加where子句\",{\"1\":{\"97\":1}}],[\"如果不添加可选项\",{\"1\":{\"66\":1}}],[\"如果不再需要保存点\",{\"1\":{\"12\":1}}],[\"如果不想提交当前事务\",{\"1\":{\"9\":1}}],[\"如果只希望撤销事务内的一部分操作\",{\"1\":{\"12\":1}}],[\"如果关闭事务的自动提交\",{\"1\":{\"11\":1}}],[\"如果执行start\",{\"1\":{\"10\":1}}],[\"如果开启事务后直到mysql会话结束时都没有提交事务\",{\"1\":{\"10\":1}}],[\"如果遇到一些外部原因\",{\"1\":{\"6\":1}}],[\"如果这一系列操作中的任意一个步骤失败\",{\"1\":{\"2\":1}}],[\"3条记录\",{\"1\":{\"42\":1}}],[\"3\",{\"0\":{\"34\":1},\"1\":{\"57\":1}}],[\"直接调用settextnode方法将它改为文本节点且内容需要和新的vnode内容一致\",{\"1\":{\"156\":1}}],[\"直接跳过\",{\"1\":{\"156\":1}}],[\"直接操作真实dom是非常消耗性能的\",{\"1\":{\"150\":1}}],[\"直接将其保存在this\",{\"1\":{\"124\":1}}],[\"直观呈现数据库设计人员对用户需求的理解\",{\"0\":{\"33\":1}}],[\"直到事务完成为止\",{\"1\":{\"5\":1}}],[\"归纳与抽象\",{\"0\":{\"33\":1}}],[\"2\",{\"0\":{\"33\":1},\"1\":{\"57\":1,\"124\":7,\"139\":1}}],[\"11\",{\"1\":{\"124\":1}}],[\"1可以\",{\"1\":{\"109\":1}}],[\"1\",{\"0\":{\"32\":1},\"1\":{\"57\":1,\"124\":7,\"139\":1}}],[\"129449631\",{\"1\":{\"29\":1}}],[\"123456\",{\"1\":{\"28\":1}}],[\"逻辑结构设计\",{\"1\":{\"31\":1}}],[\"需要把新的子节点数组里面的元素与旧的子节点数组里面的元素进行一一比对\",{\"1\":{\"157\":1}}],[\"需要考虑3种情况分别进行处理\",{\"1\":{\"156\":1}}],[\"需要注意在vue\",{\"1\":{\"124\":1}}],[\"需要查看视图的字段\",{\"1\":{\"117\":1}}],[\"需要选择utf8mb4字符集\",{\"1\":{\"58\":1}}],[\"需要通过别名对两张数据表进行区分\",{\"1\":{\"44\":1}}],[\"需要存放在mysql安装目录命名为my\",{\"1\":{\"19\":1}}],[\"需求分析\",{\"1\":{\"31\":1}}],[\"6\",{\"0\":{\"37\":1}}],[\"6个阶段\",{\"0\":{\"31\":1}}],[\"67906358\",{\"1\":{\"29\":1}}],[\"了解\",{\"0\":{\"30\":1}}],[\"三\",{\"0\":{\"30\":1}}],[\"msg\",{\"1\":{\"124\":3}}],[\"mixin\",{\"1\":{\"124\":10}}],[\"mount\",{\"1\":{\"124\":2}}],[\"modify子句\",{\"1\":{\"80\":2,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"90\":1}}],[\"modify\",{\"1\":{\"74\":1,\"76\":2,\"80\":2,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"90\":1}}],[\"mergeoptions\",{\"1\":{\"124\":2}}],[\"merge表示将引用视图的语句和定义视图的语句合并\",{\"1\":{\"114\":1}}],[\"merge\",{\"1\":{\"114\":1}}],[\"memory支持btree和hash\",{\"1\":{\"106\":1}}],[\"mediumtext\",{\"1\":{\"62\":1}}],[\"mediumblob\",{\"1\":{\"62\":1}}],[\"mediumint\",{\"1\":{\"62\":1}}],[\"m\",{\"1\":{\"62\":2}}],[\"m0\",{\"1\":{\"29\":1}}],[\"mycomponent\",{\"1\":{\"124\":1}}],[\"myfilter\",{\"1\":{\"124\":1}}],[\"mydirective\",{\"1\":{\"124\":1}}],[\"my\",{\"1\":{\"124\":8}}],[\"myobject\",{\"1\":{\"124\":1}}],[\"myisam存储引擎的数据表\",{\"1\":{\"10\":1}}],[\"myisam存储引擎不支持事务\",{\"1\":{\"10\":1}}],[\"mysql连接时使用索引的可能性\",{\"1\":{\"109\":1}}],[\"mysql会自动给对应的字段添加唯一索引\",{\"1\":{\"83\":1}}],[\"mysql中数据表的单行长度限制为65\",{\"1\":{\"62\":1}}],[\"mysql中的一致性主要由日志机制实现\",{\"1\":{\"4\":1}}],[\"mysql自动创建的4个数据库的作用\",{\"1\":{\"61\":1}}],[\"mysql安装目录\",{\"1\":{\"27\":1}}],[\"mysql\",{\"1\":{\"25\":2,\"61\":1}}],[\"mysql的登录和退出\",{\"0\":{\"24\":1}}],[\"mysql客户端连接服务器端使用的端口号\",{\"1\":{\"20\":1}}],[\"mysql配置文件\",{\"0\":{\"19\":1}}],[\"mysql服务名称\",{\"1\":{\"17\":1,\"18\":1,\"22\":1,\"23\":1}}],[\"mysqld\",{\"1\":{\"17\":1,\"18\":1,\"20\":1,\"21\":2}}],[\"mysql事务是一种保证一系列数据库操作\",{\"1\":{\"2\":1}}],[\"教程地址\",{\"1\":{\"29\":1}}],[\"扩展\",{\"0\":{\"29\":1},\"1\":{\"93\":1}}],[\"打开命令提示符\",{\"1\":{\"28\":1}}],[\"lastname\",{\"1\":{\"124\":2}}],[\"lookup\",{\"1\":{\"124\":1}}],[\"local\",{\"1\":{\"114\":2}}],[\"localhost\",{\"1\":{\"28\":2}}],[\"longtext\",{\"1\":{\"62\":1}}],[\"longblob\",{\"1\":{\"62\":1}}],[\"like子句和where子句为可选项\",{\"1\":{\"66\":1}}],[\"like\",{\"1\":{\"60\":2,\"66\":1,\"119\":1}}],[\"limit\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1}}],[\"linux环境\",{\"1\":{\"19\":1}}],[\"left\",{\"1\":{\"47\":1}}],[\"格式如下\",{\"1\":{\"28\":1}}],[\"修改视图\",{\"0\":{\"121\":1}}],[\"修改后字段的数据类型\",{\"1\":{\"73\":1}}],[\"修改后的字段名\",{\"1\":{\"73\":1}}],[\"修改前的字段名\",{\"1\":{\"73\":1}}],[\"修改数据\",{\"1\":{\"124\":1}}],[\"修改数据表的同时创建索引\",{\"0\":{\"108\":1}}],[\"修改数据表时设置\",{\"1\":{\"80\":1,\"83\":1,\"85\":1,\"87\":1,\"89\":1}}],[\"修改数据表中字段的排列位置\",{\"0\":{\"76\":1}}],[\"修改数据表中字段的数据类型\",{\"0\":{\"74\":1}}],[\"修改数据表字段名称\",{\"0\":{\"73\":1}}],[\"修改数据表名称\",{\"0\":{\"72\":1}}],[\"修改数据库\",{\"0\":{\"70\":1}}],[\"修改指定名称的数据库\",{\"1\":{\"70\":1}}],[\"修改和删除\",{\"0\":{\"69\":1},\"1\":{\"112\":1}}],[\"修改\",{\"1\":{\"57\":1}}],[\"修改密码\",{\"0\":{\"28\":1}}],[\"修改表结构等操作\",{\"1\":{\"10\":1}}],[\"测试是否成功\",{\"1\":{\"27\":1}}],[\"button\",{\"1\":{\"124\":1}}],[\"base\",{\"1\":{\"124\":3}}],[\"basedir=mysql安装目录\",{\"1\":{\"20\":1}}],[\"btree\",{\"1\":{\"106\":1,\"109\":1}}],[\"blob系列和text系列的字段不受单行长度限制\",{\"1\":{\"62\":1}}],[\"blob常用来存储图片\",{\"1\":{\"62\":1}}],[\"blob\",{\"1\":{\"62\":1}}],[\"blog\",{\"1\":{\"29\":1}}],[\"bigint\",{\"1\":{\"62\":1}}],[\"bind\",{\"1\":{\"124\":4}}],[\"bin\",{\"1\":{\"27\":1}}],[\"bin配置到path环境变量中\",{\"1\":{\"27\":1}}],[\"b表中有2个字段3条记录\",{\"1\":{\"42\":1}}],[\"by\",{\"1\":{\"28\":2,\"51\":2,\"52\":2,\"53\":2,\"54\":2,\"55\":2}}],[\"将旧的子节点调整到所有未处理节点之前且顺序要与新的子节点位置一致\",{\"1\":{\"157\":1}}],[\"将所有子节点创建好之后insert插入到当前元素节点里面\",{\"1\":{\"154\":1}}],[\"将已有的节点的属性全部复制到新节点中\",{\"1\":{\"151\":1}}],[\"将其截取出来即可\",{\"1\":{\"147\":1}}],[\"将真实的注释内容传进去\",{\"1\":{\"147\":1}}],[\"将ast转换成渲染函数\",{\"1\":{\"145\":1}}],[\"将字符串用正则等方式解析成ast\",{\"1\":{\"145\":1}}],[\"将字段名1移动到字段名2的后面\",{\"1\":{\"76\":2}}],[\"将用户写在template标签中的类似html内容解析成为html内容的过程\",{\"1\":{\"143\":1}}],[\"将用到该数据的地方\",{\"1\":{\"129\":1}}],[\"将依赖收集到dep管理器中\",{\"1\":{\"140\":1}}],[\"将该插件添加进已安装插件列表中\",{\"1\":{\"124\":1}}],[\"将注册好的组件保存在this\",{\"1\":{\"124\":1}}],[\"将这些记录导入视图中\",{\"1\":{\"114\":1}}],[\"将某个字段修改为表的第一个字段\",{\"1\":{\"76\":2}}],[\"将新字段添加到指定字段的后面\",{\"1\":{\"75\":1}}],[\"将数据表中新字段名添加为数据表的第一个字段\",{\"1\":{\"75\":1}}],[\"将数据库应用系统正式投入运行\",{\"0\":{\"37\":1}}],[\"将查询到的数据当作数据源\",{\"1\":{\"54\":1}}],[\"将左\",{\"1\":{\"49\":1}}],[\"将e\",{\"0\":{\"34\":1}}],[\"将分析的结果记录下来\",{\"0\":{\"32\":1}}],[\"将mysql安装目录\",{\"1\":{\"27\":1}}],[\"将事务回滚至保存点的语句\",{\"1\":{\"12\":1}}],[\"以新的vnode为标准\",{\"1\":{\"153\":1}}],[\"以分号结束即可\",{\"1\":{\"58\":1}}],[\"以及左表中满足连接条件的记录\",{\"1\":{\"48\":1}}],[\"以及右表中满足连接条件的记录\",{\"1\":{\"47\":1}}],[\"以及出现插入\",{\"1\":{\"38\":1}}],[\"以及评估磁盘空间需求等工作\",{\"0\":{\"35\":1}}],[\"以管理员身份运行命令提示符\",{\"1\":{\"27\":1}}],[\"以保证数据库的一致性\",{\"1\":{\"2\":1}}],[\"配置环境变量\",{\"0\":{\"27\":1}}],[\"quit\",{\"1\":{\"26\":1}}],[\"或在插入数据时省略了自动增长字段\",{\"1\":{\"88\":1}}],[\"或\",{\"1\":{\"26\":1}}],[\"或my\",{\"1\":{\"19\":1}}],[\"else\",{\"1\":{\"124\":8}}],[\"employee\",{\"1\":{\"110\":1}}],[\"endif\",{\"1\":{\"147\":1}}],[\"end\",{\"1\":{\"147\":1}}],[\"end冲突\",{\"1\":{\"10\":1}}],[\"enable\",{\"1\":{\"124\":1}}],[\"env\",{\"1\":{\"124\":8}}],[\"encryption\",{\"1\":{\"70\":2}}],[\"engines\",{\"1\":{\"65\":1}}],[\"extension\",{\"1\":{\"124\":1}}],[\"extend方法将其变为vue的子类\",{\"1\":{\"124\":1}}],[\"extended\",{\"1\":{\"124\":1}}],[\"extendoptions\",{\"1\":{\"124\":9}}],[\"extend的作用是创建一个继承vue类的子类\",{\"1\":{\"124\":1}}],[\"extend中它必须是函数\",{\"1\":{\"124\":1}}],[\"extend\",{\"1\":{\"124\":12}}],[\"extra\",{\"1\":{\"68\":1}}],[\"export\",{\"1\":{\"124\":1}}],[\"explain\",{\"1\":{\"110\":1}}],[\"expression\",{\"1\":{\"109\":1}}],[\"expr\",{\"1\":{\"60\":2,\"66\":1}}],[\"exists\",{\"1\":{\"55\":1,\"59\":2,\"64\":2,\"71\":1,\"78\":2}}],[\"exists子查询\",{\"0\":{\"55\":1}}],[\"exit\",{\"1\":{\"26\":1}}],[\"eg\",{\"1\":{\"28\":1,\"110\":1,\"122\":1}}],[\"退出\",{\"0\":{\"26\":1}}],[\"回滚事务\",{\"1\":{\"57\":1}}],[\"回滚事务后\",{\"1\":{\"12\":1}}],[\"回车\",{\"1\":{\"25\":1}}],[\"push\",{\"1\":{\"124\":1}}],[\"plugin\",{\"1\":{\"124\":17}}],[\"p>\",{\"1\":{\"124\":2,\"156\":1}}],[\"private\",{\"1\":{\"124\":1}}],[\"primary使用反引号\",{\"1\":{\"111\":1}}],[\"primary\",{\"1\":{\"85\":5,\"86\":1,\"106\":1,\"108\":1}}],[\"proto\",{\"1\":{\"139\":1}}],[\"prototype之间\",{\"1\":{\"139\":1}}],[\"prototype之间让数组实例访问的是自己封装的方法\",{\"1\":{\"139\":1}}],[\"prototype\",{\"1\":{\"124\":3}}],[\"propertyname\",{\"1\":{\"124\":4}}],[\"props\",{\"1\":{\"124\":1}}],[\"promise\",{\"1\":{\"124\":5}}],[\"production\",{\"1\":{\"124\":4}}],[\"process\",{\"1\":{\"124\":4}}],[\"profile\",{\"1\":{\"124\":1}}],[\"profile=vue\",{\"1\":{\"124\":1}}],[\"polyfill\",{\"1\":{\"124\":2}}],[\"point\",{\"1\":{\"124\":2}}],[\"port\",{\"1\":{\"20\":1}}],[\"port=3306\",{\"1\":{\"20\":1}}],[\"parameters\",{\"1\":{\"124\":1}}],[\"part为null\",{\"1\":{\"109\":1}}],[\"part\",{\"1\":{\"109\":1}}],[\"packed\",{\"1\":{\"109\":1}}],[\"pattern\",{\"1\":{\"60\":2,\"66\":1}}],[\"path\",{\"1\":{\"27\":2}}],[\"pdf文档等二进制数据\",{\"1\":{\"62\":1}}],[\"performance\",{\"1\":{\"61\":1}}],[\"p\",{\"1\":{\"25\":1}}],[\"p密码\",{\"1\":{\"25\":1}}],[\"ppassword\",{\"1\":{\"25\":1}}],[\"ui是页面\",{\"1\":{\"126\":1}}],[\"ui=render\",{\"1\":{\"126\":1}}],[\"usage\",{\"1\":{\"124\":1}}],[\"use\",{\"1\":{\"63\":1,\"124\":5}}],[\"user或current\",{\"1\":{\"114\":1}}],[\"user\",{\"1\":{\"28\":2,\"114\":2}}],[\"username\",{\"1\":{\"25\":2}}],[\"unsupported\",{\"1\":{\"124\":1}}],[\"unshift\",{\"1\":{\"124\":2}}],[\"unbind\",{\"1\":{\"124\":1}}],[\"undefined表示未指定处理方式\",{\"1\":{\"114\":1}}],[\"undefined\",{\"1\":{\"114\":1}}],[\"unique|fulltext|spatial\",{\"1\":{\"107\":1}}],[\"unique\",{\"1\":{\"82\":3,\"83\":3,\"106\":2,\"108\":1,\"109\":1}}],[\"union\",{\"1\":{\"45\":1}}],[\"update\",{\"1\":{\"96\":1,\"97\":1,\"122\":1,\"124\":4}}],[\"update和delete\",{\"1\":{\"57\":1}}],[\"utf8mb4\",{\"1\":{\"61\":2}}],[\"utf8mb4中的单个字符允许占用4个字节\",{\"1\":{\"58\":1}}],[\"utf8mb4字符集默认的校对集为utf8mb4\",{\"1\":{\"58\":1}}],[\"utf8中的单个字符最多占用3个字节\",{\"1\":{\"58\":1}}],[\"u用户名\",{\"1\":{\"25\":1}}],[\"u\",{\"1\":{\"25\":2}}],[\"html基础\",{\"0\":{\"162\":1}}],[\"html注释是以结尾\",{\"1\":{\"147\":1}}],[\"html注释\",{\"1\":{\"147\":1}}],[\"html解析器\",{\"0\":{\"147\":1}}],[\"html解析器是主线\",{\"1\":{\"146\":1}}],[\"https\",{\"1\":{\"29\":1}}],[\"hi\",{\"1\":{\"124\":1}}],[\"heisenberg<\",{\"1\":{\"124\":1}}],[\"heisenberg\",{\"1\":{\"124\":1}}],[\"hello\",{\"0\":{\"0\":1},\"1\":{\"124\":2}}],[\"have\",{\"1\":{\"124\":1}}],[\"having\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1}}],[\"hash\",{\"1\":{\"106\":1,\"109\":1}}],[\"h是mysql的主机名或ip\",{\"1\":{\"25\":1}}],[\"hostname\",{\"1\":{\"25\":2}}],[\"h\",{\"1\":{\"25\":2,\"124\":2}}],[\"明文\",{\"1\":{\"25\":1}}],[\"登录成功后将root用户的密码设置为123456\",{\"1\":{\"28\":1}}],[\"登录\",{\"0\":{\"25\":1}}],[\"密码设置\",{\"0\":{\"24\":1}}],[\"二者选一即可\",{\"1\":{\"106\":1}}],[\"二\",{\"0\":{\"24\":1},\"1\":{\"39\":1}}],[\"停止mysql服务\",{\"0\":{\"23\":1}}],[\"默认\",{\"1\":{\"114\":1}}],[\"默认执行者为创建视图的用户\",{\"1\":{\"114\":1}}],[\"默认使用merge\",{\"1\":{\"114\":1}}],[\"默认从1开始\",{\"1\":{\"109\":1}}],[\"默认值\",{\"1\":{\"89\":3}}],[\"默认值约束可以在创建数据表时设置\",{\"1\":{\"89\":1}}],[\"默认值约束通过default关键字设置\",{\"1\":{\"89\":1}}],[\"默认值约束用于给数据表中的字段指定默认值\",{\"1\":{\"89\":1}}],[\"默认值0\",{\"1\":{\"62\":1}}],[\"默认值10\",{\"1\":{\"62\":1}}],[\"默认选项\",{\"1\":{\"45\":1}}],[\"默认为3306\",{\"1\":{\"20\":1}}],[\"默认情况下\",{\"1\":{\"7\":1,\"88\":1}}],[\"watcher\",{\"1\":{\"134\":1}}],[\"walter\",{\"1\":{\"124\":1}}],[\"white\",{\"1\":{\"124\":2}}],[\"where子句用于设置删除的条件\",{\"1\":{\"99\":1}}],[\"where子句用于指定表中要更新的记录\",{\"1\":{\"96\":1}}],[\"where后跟指定条件\",{\"1\":{\"96\":1}}],[\"where\",{\"1\":{\"51\":2,\"52\":2,\"53\":2,\"54\":1,\"55\":2,\"60\":1,\"96\":1,\"99\":1,\"110\":1}}],[\"with\",{\"1\":{\"114\":2}}],[\"windows\",{\"1\":{\"19\":1}}],[\"work显式地开启一个事务\",{\"1\":{\"10\":1}}],[\"卸载命令\",{\"0\":{\"18\":1}}],[\"启动mysql服务\",{\"0\":{\"22\":1},\"1\":{\"16\":1}}],[\"初始化mysql数据库\",{\"0\":{\"21\":1},\"1\":{\"16\":1}}],[\"安装版本号\",{\"1\":{\"124\":1}}],[\"安装\",{\"1\":{\"124\":1}}],[\"安装命令\",{\"0\":{\"17\":1}}],[\"安装mysql服务\",{\"1\":{\"16\":1}}],[\"安装和启动mysql\",{\"0\":{\"15\":1}}],[\"流程\",{\"0\":{\"16\":1}}],[\"🎉\",{\"0\":{\"14\":1}}],[\"入门\",{\"0\":{\"14\":1}}],[\"一边解析不同的内容一边调用对应的钩子函数生成对应的ast节点\",{\"1\":{\"147\":1}}],[\"一定要区分字符\",{\"1\":{\"62\":1}}],[\"一张数据表与它自身连接\",{\"1\":{\"44\":1}}],[\"一个数据表中只能有一个字段设置auto\",{\"1\":{\"88\":1}}],[\"一个字段不能有多个值\",{\"1\":{\"38\":1}}],[\"一个事务中可以创建多个保存点\",{\"1\":{\"13\":1}}],[\"一般通过绘制e\",{\"0\":{\"33\":1}}],[\"一\",{\"0\":{\"15\":1},\"1\":{\"39\":1}}],[\"一致性指事务只能将数据库状态从一个一致性状态转变为另一个一致性状态\",{\"1\":{\"4\":1}}],[\"一致性\",{\"1\":{\"2\":1}}],[\"rtree\",{\"1\":{\"109\":1}}],[\"right\",{\"1\":{\"48\":1}}],[\"r图转换为数据库管理系统所支持的数据模型\",{\"0\":{\"34\":1}}],[\"r图\",{\"0\":{\"33\":1}}],[\"root\",{\"1\":{\"28\":1}}],[\"rollback语句只能针对未提交的事务回滚\",{\"1\":{\"10\":1}}],[\"rollback\",{\"1\":{\"9\":1,\"12\":1}}],[\"render\",{\"1\":{\"124\":3}}],[\"rename\",{\"1\":{\"72\":2,\"73\":1}}],[\"res\",{\"1\":{\"124\":3}}],[\"recursive\",{\"1\":{\"124\":1}}],[\"registers\",{\"1\":{\"124\":1}}],[\"return\",{\"1\":{\"124\":17,\"139\":1}}],[\"replace\",{\"1\":{\"114\":2,\"121\":1}}],[\"read\",{\"1\":{\"70\":2}}],[\"remove\",{\"1\":{\"18\":1}}],[\"release\",{\"1\":{\"12\":1}}],[\"删除子节点\",{\"1\":{\"157\":1}}],[\"删除节点\",{\"0\":{\"155\":1},\"1\":{\"153\":1}}],[\"删除对象的属性\",{\"1\":{\"124\":1}}],[\"删除视图时只会删除所创建的视图\",{\"1\":{\"123\":1}}],[\"删除视图\",{\"0\":{\"123\":1}}],[\"删除主键索引时\",{\"1\":{\"111\":1}}],[\"删除主键约束\",{\"0\":{\"86\":1}}],[\"删除索引\",{\"0\":{\"111\":1}}],[\"删除默认值约束\",{\"0\":{\"90\":1}}],[\"删除唯一约束\",{\"0\":{\"84\":1}}],[\"删除非空约束\",{\"1\":{\"80\":1}}],[\"删除数据\",{\"0\":{\"98\":1}}],[\"删除数据表\",{\"0\":{\"78\":1}}],[\"删除数据表中的指定字段\",{\"0\":{\"77\":1}}],[\"删除数据库\",{\"0\":{\"71\":1}}],[\"删除\",{\"1\":{\"38\":1,\"57\":1,\"132\":1}}],[\"删除保存点的语句\",{\"1\":{\"12\":1}}],[\"删除等\",{\"1\":{\"2\":1}}],[\"在删除节点的父元素上调用removechild方法即可\",{\"1\":{\"155\":1}}],[\"在浏览器端等同于document\",{\"1\":{\"154\":1}}],[\"在视图渲染之前\",{\"1\":{\"152\":1}}],[\"在解析过程中如果碰到文本内容\",{\"1\":{\"146\":1}}],[\"在watcher的构造函数中\",{\"1\":{\"134\":1}}],[\"在windows平台下\",{\"1\":{\"58\":1}}],[\"在该钩子函数内部\",{\"1\":{\"147\":1}}],[\"在该方法中通过window\",{\"1\":{\"134\":1}}],[\"在该数据的setter中通知更新\",{\"1\":{\"131\":1}}],[\"在该数据的getter中收集\",{\"1\":{\"130\":1}}],[\"在该函数内部\",{\"1\":{\"124\":1}}],[\"在日常业务开发中也几乎用不到\",{\"1\":{\"124\":1}}],[\"在render函数中编译模板字符串\",{\"1\":{\"124\":1}}],[\"在用法回顾中说了\",{\"1\":{\"124\":1}}],[\"在修改数据之后立即使用这个方法\",{\"1\":{\"124\":1}}],[\"在下次dom更新循环结束后执行延迟回调\",{\"1\":{\"124\":1}}],[\"在创建主键约束时\",{\"1\":{\"103\":1}}],[\"在创建唯一约束时\",{\"1\":{\"103\":1}}],[\"在使用时省略where子句即可\",{\"1\":{\"100\":1}}],[\"在数据表中可以为多个字段同时设置非空约束\",{\"1\":{\"80\":1}}],[\"在数据库运行和维护阶段\",{\"0\":{\"37\":1}}],[\"在进行比较和排序等操作时都会用到校对集\",{\"1\":{\"58\":1}}],[\"在选择项中仅需选择其中一项\",{\"1\":{\"58\":1}}],[\"在linux平台下\",{\"1\":{\"58\":1}}],[\"在指定的集合范围之内\",{\"1\":{\"52\":1}}],[\"在物理上为同一张数据表\",{\"1\":{\"44\":1}}],[\"在运行过程中不断进行一些维护\",{\"0\":{\"37\":1}}],[\"在非mysql安装目录的bin中登录mysql\",{\"1\":{\"27\":1}}],[\"在提交事务后\",{\"1\":{\"13\":1}}],[\"在事务中设置保存点的语句\",{\"1\":{\"12\":1}}],[\"在一个单一的工作单元中的完整性\",{\"1\":{\"2\":1}}],[\"shouldkeepcomment\",{\"1\":{\"147\":1}}],[\"show\",{\"1\":{\"60\":2,\"61\":2,\"65\":1,\"66\":1,\"67\":1,\"109\":1,\"119\":1,\"120\":1}}],[\"split\",{\"1\":{\"124\":1}}],[\"span><\",{\"1\":{\"124\":1}}],[\"spatial\",{\"1\":{\"106\":1}}],[\"s\",{\"1\":{\"124\":3}}],[\"so\",{\"1\":{\"124\":1}}],[\"some\",{\"1\":{\"52\":1}}],[\"superoptions\",{\"1\":{\"124\":1}}],[\"superid\",{\"1\":{\"124\":4}}],[\"super\",{\"1\":{\"124\":12}}],[\"sub\",{\"1\":{\"109\":1,\"124\":23}}],[\"smallint\",{\"1\":{\"62\":1}}],[\"school\",{\"1\":{\"61\":2}}],[\"school只是实例\",{\"1\":{\"61\":2}}],[\"schema\",{\"1\":{\"61\":2}}],[\"schemas查看已存在的数据库\",{\"1\":{\"60\":1}}],[\"sys\",{\"1\":{\"61\":1}}],[\"sql\",{\"1\":{\"114\":1}}],[\"sql语句可以在单行或多行中书写\",{\"1\":{\"58\":1}}],[\"sql根据功能分为了\",{\"1\":{\"57\":1}}],[\"string\",{\"1\":{\"124\":6}}],[\"state是数据\",{\"1\":{\"126\":1}}],[\"state\",{\"1\":{\"124\":2,\"126\":1}}],[\"statement\",{\"1\":{\"114\":2}}],[\"staticrenderfns\",{\"1\":{\"124\":2}}],[\"status\",{\"1\":{\"119\":1}}],[\"start函数需要传递三个参数\",{\"1\":{\"147\":1}}],[\"start函数接收三个参数\",{\"1\":{\"147\":1}}],[\"start\",{\"1\":{\"7\":1,\"22\":1,\"147\":1}}],[\"stop\",{\"1\":{\"23\":1}}],[\"savepoint\",{\"1\":{\"12\":3}}],[\"sealedoptions\",{\"1\":{\"124\":1}}],[\"self\",{\"1\":{\"124\":1}}],[\"select语句\",{\"1\":{\"121\":2}}],[\"select和insert\",{\"1\":{\"57\":1}}],[\"select\",{\"1\":{\"11\":1,\"42\":2,\"43\":1,\"44\":1,\"45\":2,\"47\":1,\"48\":1,\"51\":2,\"52\":2,\"53\":2,\"54\":1,\"55\":2,\"110\":1,\"114\":2}}],[\"security子句\",{\"1\":{\"114\":1}}],[\"security\",{\"1\":{\"114\":1}}],[\"seq\",{\"1\":{\"109\":1}}],[\"set和vue\",{\"1\":{\"142\":1}}],[\"setter\",{\"1\":{\"138\":1}}],[\"set子句用于指定表中要修改的字段名及相应的值\",{\"1\":{\"97\":1}}],[\"set子句用于指定表中要更新的字段名及相应的值\",{\"1\":{\"96\":1}}],[\"set子句中的字段名是要更新的字段名称\",{\"1\":{\"96\":1}}],[\"setx\",{\"1\":{\"27\":1}}],[\"set\",{\"1\":{\"11\":1,\"61\":1,\"93\":1,\"96\":1,\"97\":1,\"124\":2}}],[\"事物的自动提交\",{\"0\":{\"11\":1}}],[\"事务中的保存点就会被删除\",{\"1\":{\"13\":1}}],[\"事务中如果有任何一条sql语句执行失败\",{\"1\":{\"3\":1}}],[\"事务内的所有操作将都被撤销\",{\"1\":{\"12\":1}}],[\"事务自动回滚\",{\"1\":{\"11\":1}}],[\"事务只能手动提交\",{\"1\":{\"11\":1}}],[\"事务主要是针对数据表中数据\",{\"1\":{\"10\":1}}],[\"事务不允许嵌套\",{\"1\":{\"10\":1}}],[\"事务会自动回滚\",{\"1\":{\"10\":1}}],[\"事务回滚\",{\"0\":{\"9\":1}}],[\"事务的保持点\",{\"0\":{\"12\":1}}],[\"事务的提交\",{\"0\":{\"8\":1}}],[\"事务的开启\",{\"0\":{\"7\":1}}],[\"事务的持久性不能做到百分之百的持久\",{\"1\":{\"6\":1}}],[\"事务\",{\"0\":{\"2\":1}}],[\"不再顺序去循环新旧子节点数组\",{\"1\":{\"159\":1}}],[\"不用处理\",{\"1\":{\"156\":1}}],[\"不管数据怎么变化都与该节点无关\",{\"1\":{\"156\":1}}],[\"不足之处\",{\"0\":{\"141\":1}}],[\"不推荐在应用代码中使用\",{\"1\":{\"124\":1}}],[\"不自带\",{\"1\":{\"124\":1}}],[\"不会删除基本表中的数据\",{\"1\":{\"123\":1}}],[\"不会为默认用户root生成密码\",{\"1\":{\"21\":1}}],[\"不仅可以简化用户对数据的理解\",{\"1\":{\"112\":1}}],[\"不保存视图对应的数据\",{\"1\":{\"112\":1}}],[\"不同的存储引擎允许在创建索引时指定索引类型\",{\"1\":{\"106\":1}}],[\"不使用该选项时\",{\"1\":{\"106\":1}}],[\"不需要添加任何限制条件\",{\"1\":{\"103\":1}}],[\"不在指定的集合范围之内\",{\"1\":{\"52\":1}}],[\"不能与其他数据表或视图同名\",{\"1\":{\"114\":1}}],[\"不能为空\",{\"1\":{\"73\":1}}],[\"不能仅依赖主键的一部分\",{\"1\":{\"38\":1}}],[\"不能回滚\",{\"1\":{\"10\":1}}],[\"不包括创建或删除数据库\",{\"1\":{\"10\":1}}],[\"当开始位置大于结束位置时\",{\"1\":{\"159\":1}}],[\"当指针所指向的节点被处理之后\",{\"1\":{\"159\":1}}],[\"当新的vnode与旧的vnode都是元素节点并且都包含子节点时\",{\"1\":{\"157\":1}}],[\"当前组件节点对应的vue实例\",{\"1\":{\"151\":1}}],[\"当前事务就会自动结束\",{\"1\":{\"10\":1}}],[\"当数据发生变化时\",{\"1\":{\"150\":1}}],[\"当解析开始标签时\",{\"1\":{\"147\":1}}],[\"当解析到标签的注释时\",{\"1\":{\"147\":1}}],[\"当解析到标签的文本时\",{\"1\":{\"147\":1}}],[\"当解析到注释时调用\",{\"1\":{\"147\":1}}],[\"当解析到文本时调用\",{\"1\":{\"147\":1}}],[\"当解析到结束标签时调用\",{\"1\":{\"147\":1}}],[\"当解析到开始标签时调用\",{\"1\":{\"147\":1}}],[\"当调用该钩子函数时\",{\"1\":{\"147\":1}}],[\"当\",{\"1\":{\"124\":1}}],[\"当通过视图修改数据时\",{\"1\":{\"112\":1}}],[\"当基本表中的数据发生变化时\",{\"1\":{\"112\":1}}],[\"当查询条件中使用这些字段中的第一个字段时\",{\"1\":{\"103\":1}}],[\"当表级唯一约束仅建立在一个字段上时\",{\"1\":{\"82\":1}}],[\"当表级唯一约束建立在多个字段上时\",{\"1\":{\"82\":1}}],[\"当left\",{\"1\":{\"49\":1}}],[\"当回滚到某个保存点后\",{\"1\":{\"13\":1}}],[\"当执行commit语句或rollback语句后\",{\"1\":{\"10\":1}}],[\"已提交的事务不能回滚\",{\"1\":{\"10\":1}}],[\"已经执行成功的sql语句也必须回滚\",{\"1\":{\"3\":1}}],[\"target上的值并存入依赖数组中\",{\"1\":{\"134\":1}}],[\"target=this将实例自身赋给一个全局对象然后通过let\",{\"1\":{\"134\":1}}],[\"target\",{\"1\":{\"124\":4,\"134\":1}}],[\"table语句\",{\"1\":{\"109\":1}}],[\"table语句中的modify子句或change子句以重新定义字段的方式删除非空约束\",{\"1\":{\"80\":1}}],[\"table表名\",{\"1\":{\"90\":2}}],[\"tables\",{\"1\":{\"66\":1}}],[\"tables语句查看当前数据库中的数据表\",{\"1\":{\"66\":1}}],[\"table\",{\"1\":{\"64\":1,\"67\":1,\"72\":2,\"73\":2,\"74\":2,\"75\":2,\"76\":4,\"77\":1,\"78\":1,\"80\":5,\"82\":2,\"83\":3,\"84\":1,\"85\":5,\"86\":1,\"87\":3,\"89\":3,\"101\":1,\"106\":1,\"108\":1,\"109\":1,\"111\":2,\"119\":1}}],[\"then\",{\"1\":{\"124\":1}}],[\"their\",{\"1\":{\"124\":1}}],[\"this\",{\"1\":{\"124\":29}}],[\"truncate\",{\"1\":{\"101\":1}}],[\"transaction的别名begin或begin\",{\"1\":{\"10\":1}}],[\"transaction语句会隐式执行上一个事务的提交操作\",{\"1\":{\"10\":1}}],[\"transaction语句之前\",{\"1\":{\"10\":1}}],[\"transaction\",{\"1\":{\"7\":1}}],[\"typeof\",{\"1\":{\"124\":7}}],[\"types\",{\"1\":{\"124\":4}}],[\"type\",{\"1\":{\"68\":1,\"109\":1,\"124\":18}}],[\"template中的内容对vue来说就是一堆字符串\",{\"1\":{\"144\":1}}],[\"template\",{\"1\":{\"124\":3}}],[\"temptable表示将视图的结果保存到临时表\",{\"1\":{\"114\":1}}],[\"temptable\",{\"1\":{\"114\":1}}],[\"temporary\",{\"1\":{\"64\":2,\"78\":2}}],[\"text文本内容\",{\"1\":{\"151\":1}}],[\"text注释的内容\",{\"1\":{\"151\":1}}],[\"text\",{\"1\":{\"62\":1}}],[\"timestamp类型的值和时区有关\",{\"1\":{\"62\":1}}],[\"timestamp类型的取值范围比datatime类型小\",{\"1\":{\"62\":1}}],[\"timestamp类型与datatime类型的区别\",{\"1\":{\"62\":1}}],[\"timestamp\",{\"1\":{\"62\":1}}],[\"time\",{\"1\":{\"62\":1}}],[\"tinytext\",{\"1\":{\"62\":1}}],[\"tinyblob\",{\"1\":{\"62\":1}}],[\"tinyint\",{\"1\":{\"62\":1}}],[\"tip\",{\"0\":{\"10\":1,\"13\":1,\"49\":1,\"58\":1,\"61\":1,\"62\":1,\"82\":1,\"83\":1,\"88\":1,\"103\":1}}],[\"toarray\",{\"1\":{\"124\":2}}],[\"too\",{\"1\":{\"124\":1}}],[\"to|as\",{\"1\":{\"72\":1}}],[\"to\",{\"1\":{\"12\":1,\"72\":2,\"73\":1}}],[\"显式开启事务后\",{\"1\":{\"8\":1}}],[\"导致数据库发生故障\",{\"1\":{\"6\":1}}],[\"只需要看iscomment是否为true\",{\"1\":{\"154\":1}}],[\"只需要将create\",{\"1\":{\"116\":1}}],[\"只需一个属性\",{\"1\":{\"151\":1}}],[\"只需两个属性\",{\"1\":{\"151\":1}}],[\"只更新需要更新的地方\",{\"1\":{\"150\":1}}],[\"只在独立构建时有效\",{\"1\":{\"124\":1}}],[\"只要对这些方法进行封装即可\",{\"1\":{\"138\":1}}],[\"只要是对象里面所有属性都有getter和setter\",{\"1\":{\"137\":1}}],[\"只要保证该索引只对应表中一个字段即可\",{\"1\":{\"103\":1}}],[\"只要多个字段中有一个字段不同\",{\"1\":{\"82\":1}}],[\"只对该字段起约束作用\",{\"1\":{\"82\":1}}],[\"只会占用单行的9~12字节的存储空间\",{\"1\":{\"62\":1}}],[\"只有满足了指定条件的记录才会被更新\",{\"1\":{\"96\":1}}],[\"只有在创建的数据表不存在时\",{\"1\":{\"64\":1}}],[\"只有提交后其中的操作才会生效\",{\"1\":{\"8\":1}}],[\"只有事务中所有的数据库操作都执行成功\",{\"1\":{\"3\":1}}],[\"只能从事务本身的角度来保证持久性\",{\"1\":{\"6\":1}}],[\"doctype\",{\"1\":{\"147\":1}}],[\"dom\",{\"0\":{\"153\":1},\"1\":{\"124\":3,\"153\":1}}],[\"double类型的数字\",{\"1\":{\"62\":1}}],[\"double\",{\"1\":{\"62\":1}}],[\"diff过程叫做patch过程\",{\"1\":{\"153\":1}}],[\"diff\",{\"0\":{\"153\":1}}],[\"diff算法计算出需要更新的地方\",{\"1\":{\"150\":1}}],[\"directive=\",{\"1\":{\"124\":1}}],[\"directives\",{\"1\":{\"124\":7}}],[\"directive\",{\"1\":{\"124\":14}}],[\"div>\",{\"1\":{\"124\":2}}],[\"distinct关键字\",{\"1\":{\"45\":1}}],[\"drop\",{\"1\":{\"71\":1,\"77\":2,\"78\":1,\"84\":1,\"86\":1,\"111\":4,\"123\":1}}],[\"datetime\",{\"1\":{\"62\":1}}],[\"date\",{\"1\":{\"62\":1}}],[\"data\",{\"1\":{\"124\":3,\"139\":1,\"151\":1}}],[\"data选项是特例\",{\"1\":{\"124\":1}}],[\"database\",{\"1\":{\"61\":2}}],[\"databases或show\",{\"1\":{\"60\":1}}],[\"databases|schemas\",{\"1\":{\"60\":2}}],[\"database和schema都表示数据库\",{\"1\":{\"59\":1}}],[\"database|schema\",{\"1\":{\"59\":2,\"61\":1,\"70\":2,\"71\":1}}],[\"datadir=mysql数据库文件的存放目录\",{\"1\":{\"20\":1}}],[\"dep中的通知\",{\"1\":{\"134\":1}}],[\"dep初始一个subs数组用来保存依赖并提供了\",{\"1\":{\"132\":1}}],[\"dep类\",{\"1\":{\"132\":1}}],[\"dept\",{\"1\":{\"110\":1}}],[\"demo\",{\"1\":{\"124\":1}}],[\"defineproperty实现\",{\"1\":{\"128\":1}}],[\"definer子句中的user值通常为\",{\"1\":{\"114\":1}}],[\"definer子句和sql\",{\"1\":{\"114\":1}}],[\"definer\",{\"1\":{\"114\":2}}],[\"definition\",{\"1\":{\"124\":51}}],[\"default\",{\"1\":{\"59\":2,\"68\":1,\"70\":2,\"89\":3}}],[\"delete来解决\",{\"1\":{\"142\":1}}],[\"delete\",{\"1\":{\"99\":1,\"100\":1,\"122\":1,\"124\":2}}],[\"describe\",{\"1\":{\"118\":1}}],[\"desc语句返回的信息\",{\"1\":{\"68\":1}}],[\"desc\",{\"1\":{\"68\":1,\"118\":1}}],[\"decimal\",{\"1\":{\"62\":2}}],[\"details\",{\"1\":{\"29\":1}}],[\"dcl\",{\"1\":{\"57\":1}}],[\"ddl\",{\"1\":{\"57\":1}}],[\"dml\",{\"1\":{\"57\":1}}],[\"dql\",{\"1\":{\"57\":1}}],[\"d\",{\"0\":{\"6\":1},\"1\":{\"62\":2}}],[\"iscomment用来标志一个节点是否为注释节点\",{\"1\":{\"151\":1}}],[\"is\",{\"1\":{\"124\":1}}],[\"isplainobject\",{\"1\":{\"124\":3}}],[\"ie\",{\"1\":{\"124\":1,\"147\":1}}],[\"id等data属性\",{\"1\":{\"151\":1}}],[\"id\",{\"1\":{\"124\":26}}],[\"id=\",{\"1\":{\"124\":1}}],[\"id=132\",{\"1\":{\"110\":1}}],[\"idea图形化管理工具\",{\"0\":{\"29\":1}}],[\"identified\",{\"1\":{\"28\":2}}],[\"if\",{\"1\":{\"59\":2,\"64\":2,\"71\":1,\"78\":2,\"124\":27,\"147\":1}}],[\"invoker\",{\"1\":{\"114\":1}}],[\"increment属性\",{\"1\":{\"101\":1}}],[\"increment字段的值从1开始自增\",{\"1\":{\"88\":1}}],[\"increment字段的数据类型应该是整数类型\",{\"1\":{\"88\":1}}],[\"increment的注意事项\",{\"1\":{\"88\":1}}],[\"increment\",{\"1\":{\"87\":3,\"88\":1}}],[\"indexof\",{\"1\":{\"124\":2}}],[\"indexes|index|keys\",{\"1\":{\"109\":1}}],[\"index和key为同义词\",{\"1\":{\"106\":1}}],[\"index|key\",{\"1\":{\"106\":4,\"108\":3}}],[\"index\",{\"1\":{\"84\":1,\"107\":1,\"109\":3,\"111\":4,\"124\":5}}],[\"into\",{\"1\":{\"93\":3,\"94\":1,\"122\":1}}],[\"int\",{\"1\":{\"62\":1}}],[\"intellij\",{\"0\":{\"29\":1}}],[\"information\",{\"1\":{\"61\":1}}],[\"in|any|some|all\",{\"1\":{\"52\":1}}],[\"in|not\",{\"1\":{\"52\":1}}],[\"in\",{\"1\":{\"52\":2,\"53\":1,\"109\":1}}],[\"inner\",{\"1\":{\"43\":1}}],[\"innodb存储引擎支持事务\",{\"1\":{\"10\":1}}],[\"inserted\",{\"1\":{\"124\":1}}],[\"insert中的set子句\",{\"1\":{\"93\":1}}],[\"insert\",{\"1\":{\"93\":3,\"94\":1,\"122\":2}}],[\"insecure\",{\"1\":{\"21\":1}}],[\"installedplugins\",{\"1\":{\"124\":9}}],[\"install\",{\"1\":{\"17\":1,\"124\":13}}],[\"initcomputed\",{\"1\":{\"124\":1}}],[\"initprops\",{\"1\":{\"124\":1}}],[\"init\",{\"1\":{\"124\":1}}],[\"initialize\",{\"1\":{\"21\":2}}],[\"ini\",{\"1\":{\"19\":1}}],[\"i\",{\"0\":{\"5\":1}}],[\"css基础\",{\"0\":{\"161\":1}}],[\"csdn\",{\"1\":{\"29\":1}}],[\"class\",{\"1\":{\"151\":1}}],[\"classes\",{\"1\":{\"124\":1}}],[\"click\",{\"1\":{\"124\":1}}],[\"ctor\",{\"1\":{\"124\":2}}],[\"current\",{\"1\":{\"114\":1}}],[\"children用来指定该节点的标签名\",{\"1\":{\"151\":1}}],[\"check\",{\"1\":{\"114\":2}}],[\"change子句\",{\"1\":{\"80\":2,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"90\":1}}],[\"change\",{\"1\":{\"73\":1,\"74\":1,\"76\":2,\"80\":2,\"83\":1,\"85\":1,\"87\":1,\"89\":1,\"90\":1}}],[\"chars\",{\"1\":{\"147\":1}}],[\"charset\",{\"1\":{\"59\":2,\"70\":2}}],[\"char固定长度\",{\"1\":{\"62\":1}}],[\"char\",{\"1\":{\"62\":1}}],[\"character\",{\"1\":{\"61\":1}}],[\"call\",{\"1\":{\"134\":1}}],[\"callback\",{\"1\":{\"124\":2}}],[\"cache\",{\"1\":{\"124\":1}}],[\"cachedctors\",{\"1\":{\"124\":4}}],[\"can\",{\"1\":{\"124\":1}}],[\"cascaded\",{\"1\":{\"114\":1}}],[\"cardinality\",{\"1\":{\"109\":1}}],[\"cid++\",{\"1\":{\"124\":1}}],[\"cid\",{\"1\":{\"124\":2}}],[\"ci\",{\"1\":{\"58\":1,\"61\":1}}],[\"createtextnode\",{\"1\":{\"154\":2}}],[\"create\",{\"1\":{\"59\":2,\"61\":3,\"64\":1,\"67\":1,\"80\":1,\"82\":2,\"85\":2,\"87\":1,\"89\":1,\"106\":1,\"107\":1,\"109\":1,\"114\":1,\"120\":1,\"121\":1,\"124\":12}}],[\"create和alter和drop\",{\"1\":{\"57\":1}}],[\"cross\",{\"1\":{\"42\":1}}],[\"count++\",{\"1\":{\"124\":1}}],[\"count\",{\"1\":{\"124\":3}}],[\"core\",{\"1\":{\"124\":2}}],[\"context\",{\"1\":{\"124\":2}}],[\"constructor\",{\"1\":{\"124\":2}}],[\"const\",{\"1\":{\"124\":12}}],[\"console\",{\"1\":{\"21\":1}}],[\"compiletofunctions\",{\"1\":{\"124\":1}}],[\"compile\",{\"1\":{\"124\":4}}],[\"componentinstance分别用来表示组件的option选项\",{\"1\":{\"151\":1}}],[\"component这三个api的分析\",{\"1\":{\"124\":1}}],[\"component小结\",{\"1\":{\"124\":1}}],[\"component\",{\"1\":{\"124\":15}}],[\"componentupdated\",{\"1\":{\"124\":1}}],[\"components\",{\"1\":{\"124\":6}}],[\"computed\",{\"1\":{\"124\":1}}],[\"comment\",{\"1\":{\"109\":2,\"147\":1}}],[\"commit\",{\"1\":{\"8\":1}}],[\"collation\",{\"1\":{\"109\":1}}],[\"collate\",{\"1\":{\"59\":2,\"61\":1,\"70\":2}}],[\"column\",{\"1\":{\"73\":2,\"74\":2,\"75\":2,\"77\":1,\"80\":2,\"83\":1,\"85\":1,\"89\":1,\"90\":1,\"109\":1}}],[\"cnf\",{\"1\":{\"19\":1}}],[\"c\",{\"0\":{\"4\":1}}],[\"advance函数是用来移动解析游标的\",{\"1\":{\"147\":1}}],[\"additional\",{\"1\":{\"124\":1}}],[\"add子句\",{\"1\":{\"83\":1,\"85\":1}}],[\"add\",{\"1\":{\"75\":2,\"83\":1,\"85\":1,\"108\":4}}],[\"apply\",{\"1\":{\"124\":4}}],[\"api\",{\"1\":{\"124\":2}}],[\"arr\",{\"1\":{\"139\":1}}],[\"array\",{\"1\":{\"124\":1}}],[\"arguments\",{\"1\":{\"124\":2}}],[\"args\",{\"1\":{\"124\":8}}],[\"article\",{\"1\":{\"29\":1}}],[\"aka\",{\"1\":{\"124\":2}}],[\"a有\",{\"1\":{\"109\":1}}],[\"age+1\",{\"1\":{\"96\":1}}],[\"age的值是18\",{\"1\":{\"96\":1}}],[\"auto\",{\"1\":{\"87\":3}}],[\"autocommit=0\",{\"1\":{\"11\":1}}],[\"autocommit\",{\"1\":{\"11\":1}}],[\"autocommit的值设置为1表示开启事务自动提交\",{\"1\":{\"11\":1}}],[\"after\",{\"1\":{\"76\":2}}],[\"after参数\",{\"1\":{\"75\":1}}],[\"ai\",{\"1\":{\"58\":1}}],[\"ast抽象语法树\",{\"0\":{\"144\":1}}],[\"assets\",{\"1\":{\"124\":2}}],[\"asset\",{\"1\":{\"124\":5}}],[\"as\",{\"1\":{\"54\":1,\"114\":1,\"121\":2}}],[\"any\",{\"1\":{\"52\":1,\"124\":1}}],[\"alias\",{\"1\":{\"124\":2}}],[\"algorithm子句\",{\"1\":{\"114\":1}}],[\"algorithm\",{\"1\":{\"114\":1}}],[\"alert\",{\"1\":{\"72\":1}}],[\"allow\",{\"1\":{\"124\":1}}],[\"all\",{\"1\":{\"52\":1}}],[\"all|distinct\",{\"1\":{\"45\":1}}],[\"all关键字\",{\"1\":{\"45\":1}}],[\"alter\",{\"1\":{\"28\":2,\"70\":2,\"73\":2,\"74\":2,\"75\":2,\"76\":4,\"77\":1,\"80\":4,\"83\":3,\"84\":1,\"85\":3,\"86\":1,\"87\":2,\"89\":2,\"90\":2,\"108\":1,\"111\":2,\"121\":1}}],[\"a表中有3个字段4条记录\",{\"1\":{\"42\":1}}],[\"a\",{\"0\":{\"3\":1}}],[\"acid\",{\"1\":{\"2\":1}}],[\"持久性指事务一旦提交\",{\"1\":{\"6\":1}}],[\"持久性\",{\"1\":{\"2\":1}}],[\"隔离性保证了未完成事务的所有操作与数据库系统的隔离\",{\"1\":{\"5\":1}}],[\"隔离性指一个事务在执行时不受其他事务的影响\",{\"1\":{\"5\":1}}],[\"隔离性\",{\"1\":{\"2\":1}}],[\"特性\",{\"1\":{\"2\":1}}],[\"过滤器id和过滤器的定义\",{\"1\":{\"124\":1}}],[\"过滤器\",{\"1\":{\"1\":1}}],[\"生命周期\",{\"1\":{\"1\":1}}],[\"虚拟dom\",{\"0\":{\"150\":1},\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
