import{_ as a,o as e,c as r,d as t}from"./app-jFZM-UYu.js";const n={},s=t(`<h2 id="数据驱动视图" tabindex="-1"><a class="header-anchor" href="#数据驱动视图" aria-hidden="true">#</a> 数据驱动视图</h2><hr><p>UI=render(state) UI是页面 state是数据</p><hr><h2 id="响应式-变化侦听" tabindex="-1"><a class="header-anchor" href="#响应式-变化侦听" aria-hidden="true">#</a> 响应式(变化侦听)</h2><h3 id="对象的响应式" tabindex="-1"><a class="header-anchor" href="#对象的响应式" aria-hidden="true">#</a> 对象的响应式</h3><p>对象的响应式是通过<strong>Object.defineProperty</strong>实现 通过一个oberver类来将一个对象转换为响应式(通过<strong>递归</strong>来将对象中的<strong>每一个属性添加setter,getter</strong>同时为每一个处理过的对象打上标识符**<strong>ob</strong>**，避免重复操作)</p><h3 id="依赖收集" tabindex="-1"><a class="header-anchor" href="#依赖收集" aria-hidden="true">#</a> 依赖收集</h3><p>将用到该数据的地方，收集起来好进行更新操作</p><h3 id="何时收集" tabindex="-1"><a class="header-anchor" href="#何时收集" aria-hidden="true">#</a> 何时收集？</h3><p>在该数据的<strong>getter中收集</strong></p><h3 id="何时通知依赖更新" tabindex="-1"><a class="header-anchor" href="#何时通知依赖更新" aria-hidden="true">#</a> 何时通知依赖更新？</h3><p>在该数据的<strong>setter中通知更新</strong></p><h3 id="收集好的依赖放置在何处" tabindex="-1"><a class="header-anchor" href="#收集好的依赖放置在何处" aria-hidden="true">#</a> 收集好的依赖放置在何处？</h3><p>依赖收集时一个数据有多个依赖者所以通过依赖管理器<strong>Dep</strong>(Dep类) Dep初始一个subs数组用来保存依赖并提供了(删除，新增，通知依赖的方法)可以在getter中新增在setter中通知</p><h3 id="何为依赖" tabindex="-1"><a class="header-anchor" href="#何为依赖" aria-hidden="true">#</a> 何为依赖？</h3><p>Vue中提供<strong>Watcher</strong>(类)为每一个依赖创建一个Watcher实例数据再变化时就通知对应的Watcher由该实例通知对应的依赖当创建Watcher实例时会把自己添加到这个依赖管理器中</p><h3 id="如何将自己添加到对应的管理器中" tabindex="-1"><a class="header-anchor" href="#如何将自己添加到对应的管理器中" aria-hidden="true">#</a> 如何将自己添加到对应的管理器中？</h3><p>在Watcher的构造函数中，调用<strong>this.get()<strong>在该方法中通过</strong>window.target=this</strong>将实例自身赋给一个全局对象然后通过let value=this.getter.call(vm,vm)获取一下被依赖的数据(目的为了触发getter收集在window.target上的值并存入依赖数组中)然后释放window.target，这样当数据变化时，触发setter更新(dep中的通知)遍历依赖(watcher)的update方法从而更新页面</p><h3 id="数组的响应式" tabindex="-1"><a class="header-anchor" href="#数组的响应式" aria-hidden="true">#</a> 数组的响应式</h3><h3 id="为什么对象和数组是两个分开实现" tabindex="-1"><a class="header-anchor" href="#为什么对象和数组是两个分开实现" aria-hidden="true">#</a> 为什么对象和数组是两个分开实现？</h3><p>对象的响应式是通过js原生提供的对象方法实现</p><h3 id="何时收集-1" tabindex="-1"><a class="header-anchor" href="#何时收集-1" aria-hidden="true">#</a> 何时收集？</h3><p>还是在getter中收集 原因： 因为返回的是一个对象，只要是对象里面所有属性都有getter和setter</p><h3 id="何时通知依赖更新-1" tabindex="-1"><a class="header-anchor" href="#何时通知依赖更新-1" aria-hidden="true">#</a> 何时通知依赖更新？</h3><p>对象是通过setter来实现对数据进行了操作，那么数组中可改变数据的方法也是对数据进行了操作，那么这些方法称为数组的&quot;setter&quot;，只要对这些方法进行封装即可</p><h3 id="数组方法拦截器" tabindex="-1"><a class="header-anchor" href="#数组方法拦截器" aria-hidden="true">#</a> 数组方法拦截器</h3><p>用来拦截数组实例与Array.prototype之间让数组实例访问的是自己封装的方法(原数组的操作没有变化只是添加了一些功能) 通过把数据的__proto__属性改为拦截器就挂载到实例和Array.prototype之间</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">arr</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;2&#39;</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="依赖收集到哪里" tabindex="-1"><a class="header-anchor" href="#依赖收集到哪里" aria-hidden="true">#</a> 依赖收集到哪里？</h3><p>observer类中，将依赖收集到Dep管理器中</p><h3 id="不足之处" tabindex="-1"><a class="header-anchor" href="#不足之处" aria-hidden="true">#</a> 不足之处</h3><p>如果给<strong>一个对象新增一个属性或删除</strong>Vue是监测不到就意味着该属性<strong>不具备响应式</strong> 如果给一个且<strong>通过下表来操作数组元素</strong>那么Vue也监测不到<strong>不具备响应式</strong></p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><p>Vue提供了<strong>Vue.set</strong>和<strong>Vue.delete</strong>来解决</p>`,35),d=[s];function i(h,o){return e(),r("div",null,d)}const p=a(n,[["render",i],["__file","数据响应式.html.vue"]]);export{p as default};
