import{_ as e,o as n,c as o,d as t}from"./app-jFZM-UYu.js";const a={},r=t(`<h1 id="虚拟dom" tabindex="-1"><a class="header-anchor" href="#虚拟dom" aria-hidden="true">#</a> 虚拟DOM?</h1><p>用一个对象来描述一个DOM节点</p><h1 id="为什么要有虚拟dom" tabindex="-1"><a class="header-anchor" href="#为什么要有虚拟dom" aria-hidden="true">#</a> 为什么要有虚拟DOM？</h1><p>因为浏览器的标准就把DOM设计的非常复杂，且Vue的特点是数据驱动视图。那么就意味着只要数据发生变化，就要操作DOM,由此可见，直接操作真实DOM是非常消耗性能的</p><h1 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h1><p>用js的计算性能来换取操作DOM所消耗的性能 我们不要盲目的去更新视图， 通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作DOM了。这也就是上面所说的用JS的计算性能来换取操作DOM的性能。 用JS模拟出一个DOM节点，称之为虚拟DOM节点。当数据发生变化时，我们对比变化前后的虚拟DOM节点，通过DOM-Diff算法计算出需要更新的地方，然后去更新需要更新的视图。</p><h1 id="虚拟don的实现" tabindex="-1"><a class="header-anchor" href="#虚拟don的实现" aria-hidden="true">#</a> 虚拟DON的实现</h1><p>Vue中 存在一个VNode类通过这个类，可以实例出不同类型的虚拟DOM节点 VNode中包含了描述一个真实DOM节点所需要的一系列属性，通过属性之间不同的搭配就可以描述出各种类型的真实DOM节点</p><h2 id="vnode的类型" tabindex="-1"><a class="header-anchor" href="#vnode的类型" aria-hidden="true">#</a> VNode的类型</h2><p>通过实例化时传入的属性参数不同主要可以搭配为以下的几种类型的节点</p><ol><li><p>注释节点</p></li><li><p>文本节点</p></li><li><p>元素节点</p></li><li><p>组件节点</p></li><li><p>函数式组件节点</p></li><li><p>克隆节点</p></li><li><p>只需两个属性：text注释的内容， isComment用来标志一个节点是否为注释节点</p></li><li><p>只需一个属性，text文本内容</p></li><li><p>更加能够描述一个节点，包括tag,data,children用来指定该节点的标签名，class,id等data属性，孩子节点</p></li><li><p>除了具备元素节点的属性外，还有componentOptions,componentInstance分别用来表示组件的option选项(如props),当前组件节点对应的Vue实例</p></li><li><p>除了组件节点的属性外，还有fnContext,fnOptions分别用来表示函数式组件对应的Vue实例，组件的option选项</p></li><li><p>将已有的节点的属性全部复制到新节点中，新旧节点唯一的区别是新节点的isCloned为true</p></li></ol><h2 id="vnode的作用" tabindex="-1"><a class="header-anchor" href="#vnode的作用" aria-hidden="true">#</a> VNode的作用</h2><p>在视图渲染之前，把写好的template模板先编译成VNode缓存下来，等到数据发送变化页面需要重新渲染的时候，我们把数据发生变化后生成的真实VNode与前一次缓存的VNode进行对比，找出差异，然后有差异的VNode对应的真实DOM节点就是需要重新渲染的节点，最后根据有差异的VNode创建出真实的DOM节点再插入视图中，最终完成一次视图更新</p><h2 id="dom-diff" tabindex="-1"><a class="header-anchor" href="#dom-diff" aria-hidden="true">#</a> DOM-Diff</h2><p>DOM-Diff过程叫做patch过程 以新的VNode为标准， 如果新的有的而旧的没有那么在旧的VNode上添加 如果新的没有的而旧的有那么就把旧的VNode上有的移除 如果某些节点在新的VNode和旧的VNode上都有，那么以新的为准更新旧的VNode,从而让新旧VNode相同</p><p>总之：就是对旧的节点进行创建节点，删除节点，更新节点</p><h3 id="创建节点" tabindex="-1"><a class="header-anchor" href="#创建节点" aria-hidden="true">#</a> 创建节点：</h3><p>VNode描述的节点有6种类型，但是可以直接创建并插入到DOM中的只有元素节点，文本节点，注释节点，所以Vue在创建节点的时候会先判断在新的VNode中有而旧的VNode中没有的节点属于那种类型，从而调用不同的方法创建并插入到DOM中</p><p>判断是否为元素节点只需判断该VNode节点是否有tag标签即可，如果有tag属性即认为是元素节点，调用createElement方法创建元素节点，如果有子节点那么就会递归遍历创建所有子节点，将所有子节点创建好之后insert插入到当前元素节点里面，最后把当前节点插入到DOM中</p><p>判断是否为注释节点，只需要看isComment是否为true，若是则调用createComment方法创建注释节点，再插入到DOM中</p><p>其中nodeOps是Vue跨平台兼容性，对所有节点操作进行了封装，例如nodeOps.createTextNode()在浏览器端等同于document.createTextNode()</p><p>如果既不是元素节点，也不是注释节点，那就是文本节点，调用createTextNode方法创建文本节点，再插入到DOM中</p><h3 id="删除节点" tabindex="-1"><a class="header-anchor" href="#删除节点" aria-hidden="true">#</a> 删除节点</h3><p>在删除节点的父元素上调用removeChild方法即可</p><h3 id="更新节点" tabindex="-1"><a class="header-anchor" href="#更新节点" aria-hidden="true">#</a> 更新节点</h3><p>静态节点</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code>// 不管数据怎么变化都与该节点无关
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>静态节点<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>需要考虑3种情况分别进行处理</p><ol><li>如果新的VNode和旧的VNode均为静态节点 直接跳过，不用处理</li><li>如果新的VNode是文本节点 如果新的VNode是文本节点表示这个节点的内容是纯文本，那么只需看旧的VNode中是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把旧的VNode里的文本改为和新的文本一样。如果旧的VNode不是文本节点，那么不管它是什么，直接调用setTextNode方法将它改为文本节点且内容需要和新的VNode内容一致</li><li>如果新的VNode是元素节点 又分两种情况 该节点包含子节点 那么此时要看旧的VNode中是否包含子节点，如果旧的VNode里也包含了子节点那就需要递归对比更新子节点。 如果旧的VNode不包含子节点，那么这个旧的VNode有可能是空节点或文本节点。 如果为空节点，那么就把新的VNode里的子节点创建一份然后插入到旧的VNode里。 如果旧的VNode中是文本节点，那么就抹除该文本节点，然后把新的VNode里的子节点创建一份然后插入到旧的VNode里 该节点不包含子节点 那就说明它是一个空节点，那么直接清空旧的VNode</li></ol><p>注意：如果新旧的VNode里都包含子节点，那么对应子节点的更新在代码里调用了updateChildren方法</p><h3 id="更新子节点" tabindex="-1"><a class="header-anchor" href="#更新子节点" aria-hidden="true">#</a> 更新子节点</h3><p>当新的VNode与旧的VNode都是元素节点并且都包含子节点时，那么这两个节点的VNode实例上的children属性就是所包含的子节点数组，需要把新的子节点数组里面的元素与旧的子节点数组里面的元素进行一一比对，那么就会出现以下四种情况</p><p>创建子节点 如果新的子节点数组里面的某个子节点在旧的子节点数组里面找不到与之对应的子节点，那么说明新的子节点数组里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点 新创建的节点插入到所有未处理节点之前，而不是插入到所有已处理节点之后</p><p>删除子节点 如果把新的子节点数组里面的每个子节点都循环完毕后，发现旧的子节点数组中还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除</p><p>移动子节点 如果新的子节点里面的某个子节点在旧的子节点数组中找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以新的子节点数组里子节点的位置为基准，调整旧的子节点数组里该节点的位置，使之与新的子节点数组里的位置相同。 将旧的子节点调整到所有未处理节点之前且顺序要与新的子节点位置一致</p><p>更新节点 如果新的子节点数组里面的某个子节点在旧的子节点数组里面找到了与之相同的子节点，并所处的位置也相同，那么就更新旧的子节点数组里该节点，使之与新的子节点数组里的该节点相同。</p><h3 id="优化更新子节点" tabindex="-1"><a class="header-anchor" href="#优化更新子节点" aria-hidden="true">#</a> 优化更新子节点</h3><p>上面所用到的更新操作的时间复杂度为n^2存在效率问题</p><h3 id="优化策略" tabindex="-1"><a class="header-anchor" href="#优化策略" aria-hidden="true">#</a> 优化策略</h3><p>不再顺序去循环新旧子节点数组，而是对比新旧子节点中特殊的位置的子节点，如： <strong>新子节点数组</strong>中所有未处理子节点的<strong>第一个节点</strong>和<strong>旧的子节点数组</strong>中所有未处理子节点的<strong>第一个子节点</strong>对比， 如果<strong>相同</strong>直接进行<strong>更新节点</strong>的操作， 如果<strong>不同</strong>再把<strong>新的子节点数组</strong>中所有未处理子节点的<strong>最后一个子节点</strong>与<strong>旧的子节点数组</strong>中所有未处理子节点的<strong>最后一个子节点</strong>对比， 如果<strong>相同</strong>那就直接进行<strong>更新节点</strong>的操作， 如果<strong>不同</strong>再把<strong>新的子节点数组</strong>中所有未处理子节点的<strong>最后一个子节点</strong>与<strong>旧的子节点数组</strong>中所有未处理子节点的<strong>第一个子节点</strong>进行对比， 如果<strong>相同</strong>，就直接进行<strong>更新节点</strong>的操作，更新完之后<strong>再将旧的子节点数组</strong>中<strong>该节点移动到</strong>与<strong>新的子节点数组里节点相同的位置</strong>， 如果<strong>不同</strong>，再把<strong>新的子节点数组</strong>中所有未处理的子节点的<strong>第一个子节点</strong>和<strong>旧的子节点数组</strong>中的所有未处理子节点的<strong>最后一个子节点</strong>对比， 如果<strong>相同</strong>那就直接进入<strong>更新节点</strong>的操作，更新完<strong>再将旧的子节点数组</strong>中的<strong>该节点移动到</strong>与<strong>新的子节点数组中节点相同的位置</strong>， <strong>如果上面都不满足，再按照之前的循环方式来查找节点</strong> 这里的循环不再是之前的顺序循环进行查找，而是从两边向中间进行查找，新旧子节点两个数组分别有两个指针，第一个指针指向第一个元素的下标，第二个指针指向最后一个元素的下标 当指针所指向的节点被处理之后，指针才会向中间进行移动(新子节点数组第一个下标和就子节点数组第一个下标只会增加，新子节点数组最后一个下标和就子节点数组最后一个下标只会减少) 当开始位置大于结束位置时，表示所有节点都已经遍历过了</p>`,40),s=[r];function d(i,p){return n(),o("div",null,s)}const l=e(a,[["render",d],["__file","虚拟DOM.html.vue"]]);export{l as default};
