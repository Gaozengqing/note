import{_ as e,o as t,c as a,d as r}from"./app-jFZM-UYu.js";const n={},d=r(`<h1 id="何为模板编译" tabindex="-1"><a class="header-anchor" href="#何为模板编译" aria-hidden="true">#</a> 何为模板编译?</h1><p>将用户写在template标签中的类似Html内容解析成为Html内容的过程 也可以说模板编译就是把用户写的模板经过一系列处理最终生成render函数的过程</p><p>有了模板编译才有VNode</p><p>为什么说是类似html内容? 因为template中除了有html标签还有模板插值和vue的指令等等</p><h1 id="渲染流程" tabindex="-1"><a class="header-anchor" href="#渲染流程" aria-hidden="true">#</a> 渲染流程</h1><p>因为vue的模板编译功能，vue会把用户写在template中的类似于html的内容解析编译，把原生的Html内容找出来，再把非原生的html找出来经过一系列的处理生成渲染函数,而render函数会将模板内容生成对应的VNode,而VNode再经过patch过程从而得到将要渲染的视图中的VNode，最后根据VNode创建真实的DOM节点并插入到视图中，最终完成视图的渲染更新</p><h1 id="模板编译如何生成render函数" tabindex="-1"><a class="header-anchor" href="#模板编译如何生成render函数" aria-hidden="true">#</a> 模板编译如何生成render函数?</h1><h2 id="ast抽象语法树" tabindex="-1"><a class="header-anchor" href="#ast抽象语法树" aria-hidden="true">#</a> AST抽象语法树</h2><p>定义自行百度 template中的内容对vue来说就是一堆字符串</p><h2 id="字符串到render函数的流程" tabindex="-1"><a class="header-anchor" href="#字符串到render函数的流程" aria-hidden="true">#</a> 字符串到render函数的流程</h2><ol><li><strong>模板解析</strong>-将字符串用正则等方式解析成AST</li><li><strong>优化</strong>-遍历AST找出其中的静态节点并打上标记</li><li><strong>代码生成</strong>-将AST转换成渲染函数</li></ol><h3 id="模板解析" tabindex="-1"><a class="header-anchor" href="#模板解析" aria-hidden="true">#</a> 模板解析</h3><p>HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。</p><p>模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据<strong>解析内容的不同</strong>分为<strong>HTML解析器</strong>，<strong>文本解析器</strong>和<strong>过滤器解析器</strong>。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数parse中先调用HTML解析器parseHTML 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p><h4 id="html解析器" tabindex="-1"><a class="header-anchor" href="#html解析器" aria-hidden="true">#</a> HTML解析器</h4><p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析HTML模板时的一些参数，同时还定义了4个钩子函数。</p><p>start -当解析到开始标签时调用 end -当解析到结束标签时调用 chars -当解析到文本时调用 comment -当解析到注释时调用</p><p>模板编译阶段主线函数parse会将HTML模板字符串转化成AST，而parseHTML是用来解析模板字符串的，把模板字符串中不同的内容提取出来之后，那么谁来把提取出来的内容生成对应的AST呢？答案就是这4个钩子函数。</p><p>start函数接收三个参数，分别是标签名tag、标签属性attrs、标签是否自闭合unary。当调用该钩子函数时，内部会调用createASTElement函数来创建元素类型的AST节点</p><p>当解析到标签的文本时，触发chars钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本。如果是动态文本，则创建动态文本类型的AST节点；如果不是动态文本，则创建纯静态文本类型的AST节点。</p><p>当解析到标签的注释时，触发comment钩子函数，该钩子函数会创建一个注释类型的AST节点</p><p>一边解析不同的内容一边调用对应的钩子函数生成对应的AST节点，最终完成将整个模板字符串转化成AST,这就是HTML解析器所要做的工作。</p><p>如何解析不同的内容？</p><p>模板字符串通常包含 文本，html注释，条件注释,DOCTYPE，开始标签，结束标签</p><p>条件注释：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;!-- [if !IE]&gt; --&gt;我是注释&lt;!--&lt; ![endif] --&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理</p><p>解析HTML注释 HTML注释是以<!--开头，以-->结尾，这两者中间的内容就是注释内容 如果模板字符串html符合注释开始的正则，那么就继续向后查找是否存在--&gt;，若存在，则把html从第4位（&quot;<!--&quot;长度为4）开始截取，直到-->处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的comment函数，将真实的注释内容传进去，创建注释类型的AST节点。</p><p>注意： 平常在模板中可以在<template></template>标签上配置comments选项来决定在渲染模板时是否保留注释，对应到代码中就是options.shouldKeepComment,如果用户配置了comments选项为true，则shouldKeepComment为true，则创建注释类型的AST节点，如不保留注释，则将<strong>游标</strong>移动到&#39;--&gt;&#39;之后，继续向后解析。</p><p>advance函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析</p><p>解析条件注释 先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的DOM树中，所以不需要调用钩子函数创建AST节点。</p><p>解析DOCTYPE 原理同解析条件注释完全相同</p><p>解析开始标签 首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征 当解析开始标签时，会调用4个钩子函数中的start函数,start函数需要传递三个参数:标签名，标签属性，是否自闭合。 标签名可以通过正则匹配的结果直接拿到，但是剩下两个就需要进一步处理</p><p>解析结束标签</p><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h3><h3 id="代码生成" tabindex="-1"><a class="header-anchor" href="#代码生成" aria-hidden="true">#</a> 代码生成</h3>`,36),s=[d];function h(p,i){return t(),a("div",null,s)}const l=e(n,[["render",h],["__file","模板解析.html.vue"]]);export{l as default};
